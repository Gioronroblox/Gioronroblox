for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
 if v:IsA("BasePart") and v.Name ~="HumanoidRootPart" then
 game:GetService("RunService").Heartbeat:connect(function()
 v.Velocity = Vector3.new(0,35,0)
    wait(0.5)
   end)
  end
end

game.Players.LocalPlayer.Character.Head.Anchored = true
game.TestService.IsSleepAllowed = false

for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
 if v:IsA("BasePart") then 
  game:GetService("RunService").Heartbeat:connect(function()
   v.Velocity = Vector3.new(-40,0,-10)
   pcall(function()
    v.CanCollide = false
   end)
   pcall(function()
    v.CanQuery = false
   end)
  end)
 end
end

local hatnameclone = {}
for _,v in next, game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:GetChildren() do
 if v:IsA("Accessory") then
  if hatnameclone[v.Name] then
   if hatnameclone[v.Name] == "s" then
    hatnameclone[v.Name] = {}
   end
   table.insert(hatnameclone[v.Name],v)
  else
   hatnameclone[v.Name] = "s"
  end
 end
end
for _,v in pairs(hatnameclone) do
 if type(v) == "table" then
  local num = 1
  for _,w in pairs(v) do
   w.Name = w.Name..num
   num = num + 1
  end
 end
end
hatnameclone = nil

local v3_net, v3_808 = Vector3.new(5000, 25.1, 0), Vector3.new(8, 0, 8)
    local function getNetlessVelocity(realPartVelocity)
        local mag = realPartVelocity.Magnitude
        if mag > 1 then
            local unit = realPartVelocity.Unit
            if (unit.Y > 0.25) or (unit.Y < -0.75) then
                return unit * (25.1 / unit.Y)
            end
        end
        return v3_net + realPartVelocity * v3_808
    end
local simradius = "shp" --simulation radius (net bypass) method
--simulation radius (net bypass) method
--"shp" - sethiddenproperty
--"ssr" - setsimulationradius
--false - disable
local antiragdoll = true --removes hingeConstraints and ballSocketConstraints from your character
local newanimate = true --disables the animate script and enables after reanimation
local discharscripts = true --disables all localScripts parented to your character before reanimation
local R15toR6 = true --tries to convert your character to r6 if its r15
local hatcollide = true --makes hats cancollide (only method 0)
local humState16 = true --enables collisions for limbs before the humanoid dies (using hum:ChangeState)
local addtools = false --puts all tools from backpack to character and lets you hold them after reanimation
local hedafterneck = false --disable aligns for head and enable after neck is removed
local loadtime = game:GetService("Players").RespawnTime + 0.5 --anti respawn delay
local method = 0 --reanimation method
--methods:
--0 - breakJoints (takes [loadtime] seconds to laod)
--1 - limbs
--2 - limbs + anti respawn
--3 - limbs + breakJoints after [loadtime] seconds
--4 - remove humanoid + breakJoints
--5 - remove humanoid + limbs
local alignmode = 3 --AlignPosition mode
--modes:
--1 - AlignPosition rigidity enabled true
--2 - 2 AlignPositions rigidity enabled both true and false
--3 - AlignPosition rigidity enabled false

healthHide = healthHide and ((method == 0) or (method == 2) or (method == 000)) and gp(c, "Head", "BasePart")

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = v3(0, 0, 0)
local inf = math.huge

local c = lp.Character

if not (c and c.Parent) then
 return
end

c.Destroying:Connect(function()
 c = nil
end)

local function gp(parent, name, className)
 if typeof(parent) == "Instance" then
  for i, v in pairs(parent:GetChildren()) do
   if (v.Name == name) and v:IsA(className) then
    return v
   end
  end
 end
 return nil
end

local function align(Part0, Part1)
 Part0.CustomPhysicalProperties = PhysicalProperties.new(0.0001, 0.0001, 0.0001, 0.0001, 0.0001)

 local att0 = Instance.new("Attachment", Part0)
  att0.Orientati
  att0.Positi
 att0.Name = "att0_" .. Part0.Name
 local att1 = Instance.new("Attachment", Part1)
  att1.Orientati
  att1.Positi
 att1.Name = "att1_" .. Part1.Name

 if (alignmode == 1) or (alignmode == 2) then
  local ape = Instance.new("AlignPosition", att0)
  ape.ApplyAtCenterOfMass = false
  ape.MaxForce = inf
  ape.MaxVelocity = inf
   ape.Reacti
   ape.Resp
  ape.Attachment1 = att1
  ape.Attachment0 = att0
  ape.Name = "AlignPositionRtrue"
  ape.RigidityEnabled = true
 end

 if (alignmode == 2) or (alignmode == 3) then
  local apd = Instance.new("AlignPosition", att0)
  apd.ApplyAtCenterOfMass = false
  apd.MaxForce = inf
  apd.MaxVelocity = inf
   apd.Reacti
   apd.Resp
  apd.Attachment1 = att1
  apd.Attachment0 = att0
  apd.Name = "AlignPositionRfalse"
  apd.RigidityEnabled = false
 end

 local ao = Instance.new("AlignOrientation", att0)
 ao.MaxAngularVelocity = inf
 ao.MaxTorque = inf
  ao.PrimaryAxis
  ao.Reacti
  ao.Resp
 ao.Attachment1 = att1
 ao.Attachment0 = att0
 ao.RigidityEnabled = false

 if type(getNetlessVelocity) == "function" then
     local realVelocity = v3_0
         local steppedc
            Part0.Velocity = realVelocity
        end)
         local heartbeatc
            realVelocity = Part0.Velocity
            Part0.Velocity = getNetlessVelocity(realVelocity)
        end)
        Part0.Destroying:Connect(function()
            Part0 = nil
            steppedcon:Disconnect()
            heartbeatcon:Disconnect()
        end)
    end
end

local function respawnrequest()
 local ccfr = ws.CurrentCamera.CFrame
 local c = lp.Character
 lp.Character = nil
 lp.Character = c
  local c
  c
     if (prop ~= "Parent") and (prop ~= "CFrame") then
         return
     end
     ws.CurrentCamera.CFrame = ccfr
     con:Disconnect()
    end)
end

local destroyhum = (method == 4) or (method == 5)
local breakjoints = (method == 0) or (method == 4)
local antirespawn = (method == 0) or (method == 2) or (method == 3)

hatcollide = hatcollide and (method == 0)

addtools = addtools and gp(lp, "Backpack", "Backpack")

local fenv = getfenv()
local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.set_hidden_prop or fenv.sethiddenprop
local ssr = fenv.setsimulationradius or fenv.set_simulation_radius or fenv.set_sim_radius or fenv.setsimradius or fenv.set_simulation_rad or fenv.setsimulationrad

if shp and (simradius == "shp") then
 spawn(function()
  while c and heartbeat:Wait() do
   shp(lp, "SimulationRadius", inf)
  end
 end)
elseif ssr and (simradius == "ssr") then
 spawn(function()
  while c and heartbeat:Wait() do
   ssr(inf)
  end
 end)
end

antiragdoll = antiragdoll and function(v)
 if v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint") then
  v.Parent = nil
 end
end

if antiragdoll then
 for i, v in pairs(c:GetDescendants()) do
  antiragdoll(v)
 end
 c.DescendantAdded:Connect(antiragdoll)
end

if antirespawn then
 respawnrequest()
end

if method == 0 then
 wait(loadtime)
 if not c then
  return
 end
end

if discharscripts then
 for i, v in pairs(c:GetChildren()) do
  if v:IsA("LocalScript") then
   v.Disabled = true
  end
 end
elseif newanimate then
 local animate = gp(c, "Animate", "LocalScript")
 if animate and (not animate.Disabled) then
  animate.Disabled = true
 else
  newanimate = false
 end
end

if addtools then
 for i, v in pairs(addtools:GetChildren()) do
  if v:IsA("Tool") then
   v.Parent = c
  end
 end
end

pcall(function()
 settings().Physics.AllowSleep = false
  settings().Physics.PhysicsEnvir
end)

local OLDscripts = {}

for i, v in pairs(c:GetDescendants()) do
 if v.ClassName == "Script" then
  table.insert(OLDscripts, v)
 end
end

local scriptNames = {}

for i, v in pairs(c:GetDescendants()) do
 if v:IsA("BasePart") then
  local newName = tostring(i)
  local exists = true
  while exists do
   exists = false
   for i, v in pairs(OLDscripts) do
    if v.Name == newName then
     exists = true
    end
   end
   if exists then
    newName = newName .. "_"    
   end
  end
  table.insert(scriptNames, newName)
  Instance.new("Script", v).Name = newName
 end
end

c.Archivable = true
local hum = c:FindFirstChildOfClass("Humanoid")
if hum then
 for i, v in pairs(hum:GetPlayingAnimationTracks()) do
  v:Stop()
 end
end
local cl = c:Clone()
if hum and humState16 then
    hum:ChangeState(Enum.HumanoidStateType.Physics)
    if destroyhum then
        wait(1.6)
    end
end
if hum and hum.Parent and destroyhum then
    hum:Destroy()
end

if not c then
    return
end

local head = gp(c, "Head", "BasePart")
local torso = gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")
if hatcollide and c:FindFirstChildOfClass("Tool") then
    local anything = c:FindFirstChildOfClass("BodyColors") or gp(c, "Health", "Script")
    if not (torso and root and anything) then
        return
    end
    --torso:Destroy()
    --root:Destroy()
    if shp then
        for i,v in pairs(c:GetChildren()) do
            if v:IsA("Tools") then
                shp(v, "BackendAccoutrementState", 0)
            end 
        end
    end
    --anything:Destroy()
    if head then
        
    end
end

for i, v in pairs(cl:GetDescendants()) do
 if v:IsA("BasePart") then
  v.Transparency = 1
  v.Anchored = false
 end
end

local model = Instance.new("Model", c)
model.Name = model.ClassName

model.Destroying:Connect(function()
 model = nil
end)

for i, v in pairs(c:GetChildren()) do
 if v ~= model then
  if addtools and v:IsA("Tool") then
   for i1, v1 in pairs(v:GetDescendants()) do
    if v1 and v1.Parent and v1:IsA("BasePart") then
     local bv = Instance.new("BodyVelocity", v1)
     bv.Velocity = v3_0
     bv.MaxForce = v3(1000, 1000, 1000)
     bv.P = 1250
     bv.Name = "bv_" .. v.Name
    end
   end
  end
  v.Parent = model
 end
end

if breakjoints then
 model:BreakJoints()
else
 if head and torso then
  for i, v in pairs(model:GetDescendants()) do
   if v:IsA("Weld") or v:IsA("Snap") or v:IsA("Glue") or v:IsA("Motor") or v:IsA("Motor6D") then
    local save = false
    if (v.Part0 == torso) and (v.Part1 == head) then
     save = true
    end
    if (v.Part0 == head) and (v.Part1 == torso) then
     save = true
    end
    if save then
     if hedafterneck then
      hedafterneck = v
     end
    else
     v:Destroy()
    end
   end
  end
 end
 if method == 3 then
  spawn(function()
   wait(loadtime)
   if model then
    model:BreakJoints()
   end
  end)
 end
end

cl.Parent = c
for i, v in pairs(cl:GetChildren()) do
 v.Parent = c
end
cl:Destroy()

local modelDes = {}
for i, v in pairs(model:GetDescendants()) do
 if v:IsA("BasePart") then
  i = tostring(i)
  v.Destroying:Connect(function()
   modelDes[i] = nil
  end)
  modelDes[i] = v
 end
end
 local modelcolc
local function modelcolf()
 if model then
  for i, v in pairs(modelDes) do
   v.CanCollide = false
  end
 else
  modelcolcon:Disconnect()
 end
end
 modelcolc
modelcolf()

for i, scr in pairs(model:GetDescendants()) do
 if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
  local Part0 = scr.Parent
  if Part0:IsA("BasePart") then
   for i1, scr1 in pairs(c:GetDescendants()) do
    if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
     local Part1 = scr1.Parent
     if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
      align(Part0, Part1)
      break
     end
    end
   end
  end
 end
end

if (typeof(hedafterneck) == "Instance") and head then
 local aligns = {}
  local c
  c
     if (prop == "Parent") and not hedafterneck.Parent then
         con:Disconnect()
      for i, v in pairs(aligns) do
       v.Enabled = true
      end
  end
 end)
 for i, v in pairs(head:GetDescendants()) do
  if v:IsA("AlignPosition") or v:IsA("AlignOrientation") then
   i = tostring(i)
   aligns[i] = v
   v.Destroying:Connect(function()
       aligns[i] = nil
   end)
   v.Enabled = false
  end
 end
end

for i, v in pairs(c:GetDescendants()) do
 if v and v.Parent then
  if v.ClassName == "Script" then
   if table.find(scriptNames, v.Name) then
    v:Destroy()
   end
  elseif not v:IsDescendantOf(model) then
   if v:IsA("Decal") then
    v.Transparency = 1
   elseif v:IsA("ForceField") then
    v.Visible = false
   elseif v:IsA("Sound") then
    v.Playing = false
   elseif v:IsA("BillboardGui") or v:IsA("SurfaceGui") or v:IsA("ParticleEmitter") or v:IsA("Fire") or v:IsA("Smoke") or v:IsA("Sparkles") then
    v.Enabled = false
   end
  end
 end
end

if newanimate then
 local animate = gp(c, "Animate", "LocalScript")
 if animate then
  animate.Disabled = false
 end
end

if addtools then
 for i, v in pairs(c:GetChildren()) do
  if v:IsA("Tool") then
   v.Parent = addtools
  end
 end
end

local hum0 = model:FindFirstChildOfClass("Humanoid")
if hum0 then
    hum0.Destroying:Connect(function()
        hum0 = nil
    end)
end

local hum1 = c:FindFirstChildOfClass("Humanoid")
if hum1 then
    hum1.Destroying:Connect(function()
        hum1 = nil
    end)
end

if hum1 then
 ws.CurrentCamera.CameraSubject = hum1
  local camSubC
 local function camSubFunc()
  camSubCon:Disconnect()
  if c and hum1 then
   ws.CurrentCamera.CameraSubject = hum1
  end
 end
  camSubC
 if hum0 then
  hum0.Changed:Connect(function(prop)
   if hum1 and (prop == "Jump") then
    hum1.Jump = hum0.Jump
   end
  end)
 else
  respawnrequest()
 end
end

local rb = Instance.new("BindableEvent", c)
rb.Event:Connect(function()
 rb:Destroy()
 sg:SetCore("ResetButtonCallback", true)
 if destroyhum then
  c:BreakJoints()
  return
 end
 if hum0 and (hum0.Health > 0) then
  model:BreakJoints()
  hum0.Health = 0
 end
 if antirespawn then
     respawnrequest()
 end
end)
sg:SetCore("ResetButtonCallback", rb)

spawn(function()
 while c do
  if hum0 and hum1 then
   hum1.Jump = hum0.Jump
  end
  wait()
 end
 sg:SetCore("ResetButtonCallback", true)
end)

R15toR6 = R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15)
if R15toR6 then
    local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "LowerTorso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
 if part then
     local cfr = part.CFrame
  local R6parts = { 
   head = {
    Name = "Head",
    Size = v3(2, 1, 1),
    R15 = {
     Head = 0
    }
   },
   torso = {
    Name = "Torso",
    Size = v3(2, 2, 1),
    R15 = {
     UpperTorso = 0.2,
     LowerTorso = -0.7
    }
   },
   root = {
    Name = "HumanoidRootPart",
    Size = v3(2, 2, 1),
    R15 = {
     HumanoidRootPart = 0
    }
   },
   leftArm = {
    Name = "Left Arm",
    Size = v3(1, 2, 1),
    R15 = {
     LeftHand = -0.7,
     LeftLowerArm = -0.2,
     LeftUpperArm = 0.4
    }
   },
   rightArm = {
    Name = "Right Arm",
    Size = v3(1, 2, 1),
    R15 = {
     RightHand = -0.7,
     RightLowerArm = -0.2,
     RightUpperArm = 0.4
    }
   },
   leftLeg = {
    Name = "Left Leg",
    Size = v3(1, 2, 1),
    R15 = {
     LeftFoot = -0.7,
     LeftLowerLeg = -0.15,
     LeftUpperLeg = 0.6
    }
   },
   rightLeg = {
    Name = "Right Leg",
    Size = v3(1, 2, 1),
    R15 = {
     RightFoot = -0.7,
     RightLowerLeg = -0.15,
     RightUpperLeg = 0.6
    }
   }
  }
  for i, v in pairs(c:GetChildren()) do
   if v:IsA("BasePart") then
    for i1, v1 in pairs(v:GetChildren()) do
     if v1:IsA("Motor6D") then
      v1.Part0 = nil
     end
    end
   end
  end
  part.Archivable = true
  for i, v in pairs(R6parts) do
   local part = part:Clone()
   part:ClearAllChildren()
   part.Name = v.Name
   part.Size = v.Size
   part.CFrame = cfr
   part.Anchored = false
   part.Transparency = 1
   part.CanCollide = false
   for i1, v1 in pairs(v.R15) do
    local R15part = gp(c, i1, "BasePart")
    local att = gp(R15part, "att1_" .. i1, "Attachment")
    if R15part then
     local weld = Instance.new("Weld", R15part)
     weld.Name = "Weld_" .. i1
     weld.Part0 = part
     weld.Part1 = R15part
     weld.C0 = cf(0, v1, 0)
     weld.C1 = cf(0, 0, 0)
     R15part.Massless = true
     R15part.Name = "R15_" .. i1
     R15part.Parent = part
     if att then
      att.Parent = part
      att.Position = v3(0, v1, 0)
     end
    end
   end
   part.Parent = c
   R6parts[i] = part
  end
  local R6joints = {
   neck = {
    Parent = R6parts.torso,
    Name = "Neck",
    Part0 = R6parts.torso,
    Part1 = R6parts.head,
    C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
    C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
   },
   rootJoint = {
    Parent = R6parts.root,
    Name = "RootJoint" ,
    Part0 = R6parts.root,
    Part1 = R6parts.torso,
    C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
    C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
   },
   rightShoulder = {
    Parent = R6parts.torso,
    Name = "Right Shoulder",
    Part0 = R6parts.torso,
    Part1 = R6parts.rightArm,
    C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
    C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
   },
   leftShoulder = {
    Parent = R6parts.torso,
    Name = "Left Shoulder",
    Part0 = R6parts.torso,
    Part1 = R6parts.leftArm,
    C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
    C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
   },
   rightHip = {
    Parent = R6parts.torso,
    Name = "Right Hip",
    Part0 = R6parts.torso,
    Part1 = R6parts.rightLeg,
    C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
    C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
   },
   leftHip = {
    Parent = R6parts.torso,
    Name = "Left Hip" ,
    Part0 = R6parts.torso,
    Part1 = R6parts.leftLeg,
    C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
    C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
   }
  }
  for i, v in pairs(R6joints) do
   local joint = Instance.new("Motor6D")
   for prop, val in pairs(v) do
    joint[prop] = val
   end
   R6joints[i] = joint
  end
  hum1.RigType = Enum.HumanoidRigType.R6
  hum1.HipHeight = 0
 end
end

local v = "Tool"


--find rig joints

local function fakemotor()
    return {C0=cf(), C1=cf()}
end

local torso = gp(c, "Torso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")

local neck = gp(torso, "Neck", "Motor6D")
neck = neck or fakemotor()

local rootJoint = gp(root, "RootJoint", "Motor6D")
rootJoint = rootJoint or fakemotor()

local leftShoulder = gp(torso, "Left Shoulder", "Motor6D")
leftShoulder = leftShoulder or fakemotor()

local rightShoulder = gp(torso, "Right Shoulder", "Motor6D")
rightShoulder = rightShoulder or fakemotor()

local leftHip = gp(torso, "Left Hip", "Motor6D")
leftHip = leftHip or fakemotor()

local rightHip = gp(torso, "Right Hip", "Motor6D")
rightHip = rightHip or fakemotor()

--120 fps

local fps = 60
local event = Instance.new("BindableEvent", c)
event.Name = "120 fps"
local floor = math.floor
fps = 1 / fps
local tf = 0
local con = nil
con = game:GetService("RunService").RenderStepped:Connect(function(s)
 if not c then
  con:Disconnect()
  return
 end
    --tf += s
 if tf >= fps then
  for i=1, floor(tf / fps) do
   event:Fire(c)
  end
  tf = 0
 end
end)
local event = event.Event

local hedrot = v3(0, 5, 0)

local uis = game:GetService("UserInputService")
local function isPressed(key)
    return (not uis:GetFocusedTextBox()) and uis:IsKeyDown(Enum.KeyCode[key])
end

local biggesthandle = nil
for i, v in pairs(c:GetChildren()) do
    if v:IsA("Tool") then
        local handle = gp(v, "Handle", "BasePart")
        if biggesthandle then
            if biggesthandle.Size.Magnitude < handle.Size.Magnitude then
                biggesthandle = handle
            end
        else
            biggesthandle = gp(v, "Handle", "BasePart")
        end
    end
end

if not biggesthandle then
    return
end

local handle1 = gp(gp(model, biggesthandle.Parent.Name, "Tool"), "Handle", "BasePart")
if not handle1 then
    return
end

handle1.Destroying:Connect(function()
    handle1 = nil
end)
biggesthandle.Destroying:Connect(function()
    biggesthandle = nil
end)

biggesthandle:BreakJoints()
biggesthandle.Anchored = true

for i, v in pairs(handle1:GetDescendants()) do
    if v:IsA("AlignOrientation") then
        v.Enabled = false
    end
end

local mouse = lp:GetMouse()
local fling = false
mouse.Button1Down:Connect(function()
fling = true
end)

mouse.Button1Up:Connect(function()
    fling = false
end)

omgHuman = game.Players.LocalPlayer.Character.HumanoidRootPart
UselessPartLmao = Instance.new("Part", omgHuman)
UselessPartLmao.Name = "life fucking sucks and i wanna jump off a bridge"
UselessPartLmao.CanCollide = false
UselessPartLmao.Transparency = 1

well = Instance.new("Weld", UselessPartLmao)
well.Name = "Lois family guy"
well.Part0 = UselessPartLmao
well.Part1 = omgHuman
well.C0 = cf(0, 12.5, 0)
well.C1 = cf(0, 0, 0)

local function doForSignal(signal, vel)
    spawn(function()
        while signal:Wait() and c and handle1 and biggesthandle do
            if fling == true and mouse.Target then
                 biggesthandle.Positi
               
            end
            if fling == false then
                 biggesthandle.Positi

            end
            handle1.RotVelocity = Vector3.new(9999999,9999999,9999999)
        end
    end)
end
doForSignal(stepped, v3(0, 0, 0))
doForSignal(renderstepped, v3(0, 0, 0))
doForSignal(heartbeat, v3(200000000000000000000000000000, 200000000000000000000000000000, 200000000000000000000000000000))
--Hat1

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = Vector3.zero
local inf = math.huge

local cplayer = lp.Character

local v3 = Vector3.new

local function gp(parent, name, className)
    if typeof(parent) == "Instance" then
        for i, v in pairs(parent:GetChildren()) do
            if (v.Name == name) and v:IsA(className) then
                return v
            end
        end
    end
    return nil
end

for i,v in pairs (cplayer:GetChildren()) do
 if v:IsA("Accessory") then
  v.Handle.Massless = true
  v.Handle.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
 end
end

 game.Players.LocalPlayer.Character.Head.Anchored = false

plr = game.Players.LocalPlayer 
char = plr.Character
 
local lp = game:GetService("Players").LocalPlayer
local cplayer = lp.Character
local function gp(parent, name, className)
    if typeof(parent) == "Instance" then
        for i, v in pairs(parent:GetChildren()) do
            if (v.Name == name) and v:IsA(className) then
                return v
            end
        end
    end
    return nil
end
  
 
local hat2 = gp(cplayer, "Front", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Torso"] --any part of humanoid
att2.Position = Vector3.new(-0, 0, 0)
att2.Rotation = Vector3.new(0, 0, -0)--you can delete this 


local hat2 = gp(cplayer, "Extra Left hand (Blocky)_white", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Left Arm"]
att2.Position = Vector3.new(-0, -0, -0)
att2.Rotation = Vector3.new(-110, -0, 0)

local hat2 = gp(cplayer, "Extra Right hand (Blocky)_white", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Right Arm"]
att2.Position = Vector3.new(-0, -0, 0)
att2.Rotation = Vector3.new(-110, 0, -0) --LavanderHair

local hat2 = gp(cplayer, "Unloaded head", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Right Leg"]
att2.Position = Vector3.new(-0, -0, 0) --Robloxclassicred
att2.Rotation = Vector3.new(90, -90, 0)

local hat2 = gp(cplayer, "MeshPartAccessory", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Left Leg"]
att2.Position = Vector3.new(-0, -0, 0)
att2.Rotation = Vector3.new(90, 90, 0)
 
--[[
local Rockerfeller = Instance.new("Sound", Workspace)
local RockerfellerName = "Rockerfeller.mp3"
  if not isfile&#40;RockerfellerName&#41; then
writefile&#40;RockerfellerName, game:HttpGet("https://download1072.mediafire.com/nf33r019dg7g2XwfZBy6M2Ns_tr-R4IMXVPF4X-uJ9OmXjXIdIgGGD39FdhmmsOjKCMxLUdANs2u8YDAD6Xqmg6w2WRJX27j5nQBDHL_a9VPKvtrvAiKqzYQiolZkEFFcz5YyaoA8EaAsepBQSEEdS1FUyqja012plA5T1MuPQA_WQ/1v6xzup07b46ie2/rockefeller-street.mp3"&#41;)
end
Rockerfeller.SoundId = syn and getsynasset(RockerfellerName) or getcustomasset(RockerfellerName)
Rockerfeller.EmitterSize = math.huge
Rockerfeller.MaxDistance = math.huge
Rockerfeller.Looped = true
Rockerfeller.Pitch = 1
Rockerfeller.Name = "Sound"
Rockerfeller.Volume = 100
]]--

local Sinner = Instance.new("Sound", Workspace)
local SinnerName = "Sinner.mp3"
  if not isfile&#40;SinnerName&#41; then
writefile&#40;SinnerName, game:HttpGet("https://download940.mediafire.com/83bvn8stvxog2eCb6YMxr425nl1MosaHPCoJZE_ryReFRGz1xTSwzYQG-MN4ONgM9ZGK63bzSP7UTA2Obn5SJN6ud2NGYaHuTb0uSUMPQ8KLmP57miqqTCWjDm375813FRxlQRUeByQER5luk7xqtg1mI_eC5DLDxUAPIZiJ4kSxYQ/uduxg9h3tugis4j/bloodwater.mp3"&#41;)
end
Sinner.SoundId = syn and getsynasset(SinnerName) or getcustomasset(SinnerName)
Sinner.EmitterSize = math.huge
Sinner.MaxDistance = math.huge
Sinner.Looped = true
Sinner.Pitch = 1.1
Sinner.Name = "Sound"
Sinner.Volume = 1
Sinner:Play()

local Infected = Instance.new("Sound", Workspace)
local InfectedName = "Infected.mp3"
  if not isfile&#40;InfectedName&#41; then
writefile&#40;InfectedName, game:HttpGet("https://download939.mediafire.com/lm3uzez2aaygojzZDiWwJ0E0g-Nxw8we7w2ZIaQyk1FJx1gUraalkIQOsoHIfqgX4IUD9lHQh7QMzCNMO1MNISWkvGJ5ijz532obmFNldiZtWtIA5VXWyNwMRkx3oAjO2m3xP_ItfRaKmpDpQpgKbzX7Ui2fVaEp7EIxpH4ok6GgXA/2as8p30yr7n60pn/Lightning+cannon+v1.mp3"&#41;)
end
Infected.SoundId = syn and getsynasset(InfectedName) or getcustomasset(InfectedName)
Infected.EmitterSize = math.huge
Infected.MaxDistance = math.huge
Infected.Looped = true
Infected.Pitch = 1.02
Infected.Name = "Sound"
Infected.Volume = 1

local Abyst = Instance.new("Sound", Workspace)
local AbystName = "Abyst.mp3"
  if not isfile&#40;AbystName&#41; then
writefile&#40;AbystName, game:HttpGet("https://download1582.mediafire.com/xkpfvca172cgNnoveVjQ3jwb4jghALZaIrFumOyzmYpAPkALjJFsgk1qesUyGytOaUmYA3azIi6k6qwO_l1EH3EZEKHNRDYK8jFqEAV5LjrVFASeMdffMEhlyve0bOdGkWClArEUfuAa8esEWQpvicCG_PC1NrwdQ5f00AVA6x1VjA/cxnyxvqvhhou1dg/human-artifacts-found-underwater-best-dressed-lists.mp3"&#41;)
end
Abyst.SoundId = syn and getsynasset(AbystName) or getcustomasset(AbystName)
Abyst.EmitterSize = math.huge
Abyst.MaxDistance = math.huge
Abyst.Looped = true
Abyst.Pitch = 1.1
Abyst.Name = "Sound"
Abyst.Volume = 1

local Rockerfeller = Instance.new("Sound", Workspace)
local RockerfellerName = "Rockerfeller.mp3"
  if not isfile&#40;RockerfellerName&#41; then
writefile&#40;RockerfellerName, game:HttpGet("https://download1072.mediafire.com/nf33r019dg7g2XwfZBy6M2Ns_tr-R4IMXVPF4X-uJ9OmXjXIdIgGGD39FdhmmsOjKCMxLUdANs2u8YDAD6Xqmg6w2WRJX27j5nQBDHL_a9VPKvtrvAiKqzYQiolZkEFFcz5YyaoA8EaAsepBQSEEdS1FUyqja012plA5T1MuPQA_WQ/1v6xzup07b46ie2/rockefeller-street.mp3"&#41;)
end
Rockerfeller.SoundId = syn and getsynasset(RockerfellerName) or getcustomasset(RockerfellerName)
Rockerfeller.EmitterSize = math.huge
Rockerfeller.MaxDistance = math.huge
Rockerfeller.Looped = true
Rockerfeller.Name = "Sound"
Rockerfeller.Volume = 1

local KillBot = Instance.new("Sound", Workspace)
local KillBotName = "KillBot.mp3"
  if not isfile&#40;KillBotName&#41; then
writefile&#40;KillBotName, game:HttpGet("https://download1638.mediafire.com/58znupucxnsgzv8PE1kgggsSiR9OqqwRDKAGfSH1bhZfPTBbY5iZav1cAUrtruUdM-O8hoSWrE9mAoPWLn0vyIkuKgZNQjEGcwmsTo3V1iWmgHuyza-wHg_8FB_5yofuAxbSXgEMKOuKBlKrgjU_CwoXDraMUzmA5PrefOXSLHlTlA/p9m97obqg1a1fp0/regain-control.mp3"&#41;)
end
KillBot.SoundId = syn and getsynasset(KillBotName) or getcustomasset(KillBotName)
KillBot.EmitterSize = math.huge
KillBot.MaxDistance = math.huge
KillBot.Looped = true
KillBot.Pitch = 0.95
KillBot.Name = "Sound"
KillBot.Volume = 1

game:GetService("StarterGui"):SetCore("SendNotification", { 
 Title = "Melon's (FE) Converts/Scripts";
 Text = "Loaded successfully!";
  Ic
 Durati


--The reality of my life isn't real but a Universe -makhail07
wait(0.2)
local plr = game:service'Players'.LocalPlayer
Plr = plr
plr.Character.Animate:Destroy()
local char = Plr.Character

local BBoard = Instance.new("BillboardGui", char.Head)
BBoard.Adornee = char.Head
BBoard.StudsOffset = Vector3.new(-6, 4, 0)
BBoard.Size = UDim2.new(4,0,2,0)

local ModeName = Instance.new("TextLabel", BBoard)
ModeName.Text = "Sinner"
ModeName.BackgroundTransparency = 1
ModeName.TextScaled = true
ModeName.TextStrokeTransparency = 0
ModeName.TextStrokeColor3 = Color3.fromRGB(255,255,255)
ModeName.Size = BBoard.Size
 ModeName.F
ModeName.TextColor3 = Color3.fromRGB(0,0,0)

local omgitskorn =  Instance.new("Highlight")  
omgitskorn.Parent = char
omgitskorn.FillColor = Color3.fromRGB(0,0,0)
omgitskorn.FillTransparency = 1
omgitskorn.OutlineColor = Color3.fromRGB(255,255,255)

local hum = char.Humanoid
local hed = char.Head
local root = char.HumanoidRootPart
local rootj = root.RootJoint
local tors = char.Torso
local ra = char["Right Arm"]
local la = char["Left Arm"]
local rl = char["Right Leg"]
local ll = char["Left Leg"]
local neck = tors["Neck"]
local mouse = plr:GetMouse()
local RootCF = CFrame.fromEulerAnglesXYZ(-1.57, 0, 3.14)
local RHCF = CFrame.fromEulerAnglesXYZ(0, 1.6, 0)
local LHCF = CFrame.fromEulerAnglesXYZ(0, -1.6, 0)

cam = game.Workspace.CurrentCamera
CF = CFrame.new
angles = CFrame.Angles
attack = false
Euler = CFrame.fromEulerAnglesXYZ
Rad = math.rad
IT = Instance.new
BrickC = BrickColor.new
Cos = math.cos
Acos = math.acos
Sin = math.sin
Asin = math.asin
Abs = math.abs
Mrandom = math.random
Floor = math.floor
Mode = 1
necko = CF(0, 1, 0, -1, -0, -0, 0, 0, 1, 0, 1, 0)
RSH, LSH = nil, nil 
RW = Instance.new("Weld") 
LW = Instance.new("Weld")
RH = tors["Right Hip"]
LH = tors["Left Hip"]
RSH = tors["Right Shoulder"] 
LSH = tors["Left Shoulder"] 


RW.Name = "RW"
RW.Part0 = tors 
RW.C0 = CF(1.5, 0.5, 0)
RW.C1 = CF(0, 0.5, 0) 
RW.Part1 = ra
RW.Parent = tors 
LW.Name = "LW"
LW.Part0 = tors 
LW.C0 = CF(-1.5, 0.5, 0)
LW.C1 = CF(0, 0.5, 0) 
LW.Part1 = la
LW.Parent = tors
vt = Vector3.new
Effects = {}

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "Heartbeat"
script:WaitForChild("Heartbeat")

frame = 1 / 90
tf = 0
allowframeloss = false
tossremainder = false


lastframe = tick()
script.Heartbeat:Fire()
 
game:GetService("RunService").Heartbeat:connect(function(s, p)
 tf = tf + s
 if tf >= frame then
  if allowframeloss then
   script.Heartbeat:Fire()
   lastframe = tick()
  else
   for i = 1, math.floor(tf / frame) do
    script.Heartbeat:Fire()
   end
   lastframe = tick()
  end
  if tossremainder then
   tf = 0
  else
   tf = tf - frame * math.floor(tf / frame)
  end
 end
end)

function swait(num)
 if num == 0 or num == nil then
  game:service("RunService").Stepped:wait(0)
 else
  for i = 0, num do
   game:service("RunService").Stepped:wait(0)
  end
 end
end
function thread(f)
 coroutine.resume(coroutine.create(f))
end
function clerp(a, b, t)
 local qa = {
  QuaternionFromCFrame(a)
 }
 local qb = {
  QuaternionFromCFrame(b)
 }
 local ax, ay, az = a.x, a.y, a.z
 local bx, by, bz = b.x, b.y, b.z
 local _t = 1 - t
 return QuaternionToCFrame(_t * ax + t * bx, _t * ay + t * by, _t * az + t * bz, QuaternionSlerp(qa, qb, t))
end
function QuaternionFromCFrame(cf)
 local mx, my, mz, m00, m01, m02, m10, m11, m12, m20, m21, m22 = cf:components()
 local trace = m00 + m11 + m22
 if trace > 0 then
  local s = math.sqrt(1 + trace)
  local recip = 0.5 / s
  return (m21 - m12) * recip, (m02 - m20) * recip, (m10 - m01) * recip, s * 0.5
 else
  local i = 0
  if m00 < m11 then
   i = 1
  end
  if m22 > (i == 0 and m00 or m11) then
   i = 2
  end
  if i == 0 then
   local s = math.sqrt(m00 - m11 - m22 + 1)
   local recip = 0.5 / s
   return 0.5 * s, (m10 + m01) * recip, (m20 + m02) * recip, (m21 - m12) * recip
  elseif i == 1 then
   local s = math.sqrt(m11 - m22 - m00 + 1)
   local recip = 0.5 / s
   return (m01 + m10) * recip, 0.5 * s, (m21 + m12) * recip, (m02 - m20) * recip
  elseif i == 2 then
   local s = math.sqrt(m22 - m00 - m11 + 1)
   local recip = 0.5 / s
   return (m02 + m20) * recip, (m12 + m21) * recip, 0.5 * s, (m10 - m01) * recip
  end
 end
end
function QuaternionToCFrame(px, py, pz, x, y, z, w)
 local xs, ys, zs = x + x, y + y, z + z
 local wx, wy, wz = w * xs, w * ys, w * zs
 local xx = x * xs
 local xy = x * ys
 local xz = x * zs
 local yy = y * ys
 local yz = y * zs
 local zz = z * zs
 return CFrame.new(px, py, pz, 1 - (yy + zz), xy - wz, xz + wy, xy + wz, 1 - (xx + zz), yz - wx, xz - wy, yz + wx, 1 - (xx + yy))
end
function QuaternionSlerp(a, b, t)
 local cosTheta = a[1] * b[1] + a[2] * b[2] + a[3] * b[3] + a[4] * b[4]
 local startInterp, finishInterp
 if cosTheta >= 1.0E-4 then
  if 1 - cosTheta > 1.0E-4 then
   local theta = math.acos(cosTheta)
   local invSinTheta = 1 / Sin(theta)
   startInterp = Sin((1 - t) * theta) * invSinTheta
   finishInterp = Sin(t * theta) * invSinTheta
  else
   startInterp = 1 - t
   finishInterp = t
  end
 elseif 1 + cosTheta > 1.0E-4 then
  local theta = math.acos(-cosTheta)
  local invSinTheta = 1 / Sin(theta)
  startInterp = Sin((t - 1) * theta) * invSinTheta
  finishInterp = Sin(t * theta) * invSinTheta
 else
  startInterp = t - 1
  finishInterp = t
 end
 return a[1] * startInterp + b[1] * finishInterp, a[2] * startInterp + b[2] * finishInterp, a[3] * startInterp + b[3] * finishInterp, a[4] * startInterp + b[4] * finishInterp
end
function rayCast(Position, Direction, Range, Ignore)
 return game:service("Workspace"):FindPartOnRay(Ray.new(Position, Direction.unit * (Range or 999.999)), Ignore)
end

function FaceMouse()
local Cam = workspace.CurrentCamera
 return {
  CFrame.new(char.Torso.Position, Vector3.new(mouse.Hit.p.x, char.Torso.Position.y, mouse.Hit.p.z)),
  Vector3.new(mouse.Hit.p.x, mouse.Hit.p.y, mouse.Hit.p.z)
 }
end

local Player_Size = 1
if Player_Size ~= 1 then
root.Size = root.Size * Player_Size
tors.Size = tors.Size * Player_Size
hed.Size = hed.Size * Player_Size
ra.Size = ra.Size * Player_Size
la.Size = la.Size * Player_Size
rl.Size = rl.Size * Player_Size
ll.Size = ll.Size * Player_Size
----------------------------------------------------------------------------------
rootj.Parent = root
neck.Parent = tors
RW.Parent = tors
LW.Parent = tors
RH.Parent = tors
LH.Parent = tors
----------------------------------------------------------------------------------
rootj.C0 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
rootj.C1 = RootCF * CF(0 * Player_Size, 0 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0))
neck.C0 = necko * CF(0 * Player_Size, 0 * Player_Size, 0 + ((1 * Player_Size) - 1)) * angles(Rad(0), Rad(0), Rad(0))
neck.C1 = CF(0 * Player_Size, -0.5 * Player_Size, 0 * Player_Size) * angles(Rad(-90), Rad(0), Rad(180))
RW.C0 = CF(1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* RIGHTSHOULDERC0
LW.C0 = CF(-1.5 * Player_Size, 0.5 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(0), Rad(0)) --* LEFTSHOULDERC0
----------------------------------------------------------------------------------
RH.C0 = CF(1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C0 = CF(-1 * Player_Size, -1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
RH.C1 = CF(0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
LH.C1 = CF(-0.5 * Player_Size, 1 * Player_Size, 0 * Player_Size) * angles(Rad(0), Rad(-90), Rad(0)) * angles(Rad(0), Rad(0), Rad(0))
--hat.Parent = Character
end

local equipped = false
local idle = 0
local change = 1
local val = 0
local toim = 0
local idleanim = 0.4
local sine = 0
local Sit = 1
local attacktype = 1
local attackdebounce = false
local euler = CFrame.fromEulerAnglesXYZ

hum.WalkSpeed = 8
hum.JumpPower = 57

local ANIMATOR = hum.Animator
ANIMATOR.Parent = nil


local hat2 = gp(cplayer, "PogoStick", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Right Arm"]
att2.Position = Vector3.new(-0.5, -3, -0.3)
att2.Rotation = Vector3.new(35, 90, 0) --LavanderHair

plr = game.Players.LocalPlayer
mouse = plr:GetMouse()
mouse.KeyDown:connect(function(Key)
if Key == "m" and attack==false and Mode == 1 then
  Mode = 2
  ModeName.Text = "Infected"
  ModeName.TextStrokeColor3 = Color3.fromRGB(255,0,0)
  omgitskorn.OutlineColor = Color3.fromRGB(255,0,0)
  Sinner:Stop()
  Infected:Play()
  att2.Parent = cplayer["Right Arm"]
  att2.Position = Vector3.new(-0.5, -3, -0.3)
        att2.Rotation = Vector3.new(35, 90, 0) --LavanderHair
 elseif Key == "m" and Mode == 2 then
  Mode = 3
  ModeName.Text = "REALLY"
  ModeName.TextStrokeColor3 = Color3.fromRGB(255,255,255)
  omgitskorn.OutlineColor = Color3.fromRGB(255,255,255)
  Infected:Stop()
  Abyst:Play()
        att2.Parent = cplayer["Torso"]
        att2.Position = Vector3.new(0, 0, 1) --LavanderHair
        att2.Rotation = Vector3.new(0, 0, 0) --LavanderHair
  elseif Key == "m" and Mode == 3 then
  Mode = 4
  ModeName.Text = "☭IS ME☭"
  ModeName.TextStrokeColor3 = Color3.fromRGB(126, 48, 172)
  omgitskorn.OutlineColor = Color3.fromRGB(126, 48, 172)
  Abyst:Stop()
  Rockerfeller:Play()
  att2.Parent = cplayer["Right Arm"]
  att2.Position = Vector3.new(-0.5, -3, -0.3)
        att2.Rotation = Vector3.new(35, 90, 0) --LavanderHair
  elseif Key == "m" and Mode == 4 then
  Mode = 5
  ModeName.Text = "NERD"
  ModeName.TextStrokeColor3 = Color3.fromRGB(234,100,145)
  omgitskorn.OutlineColor = Color3.fromRGB(234,100,145)
  Rockerfeller:Stop()
  KillBot:Play()
  att2.Parent = cplayer["Torso"]
        att2.Position = Vector3.new(0, 0, 1) --LavanderHair
        att2.Rotation = Vector3.new(0, 0, 0) --LavanderHair
        elseif Key == "m" and Mode == 5 then
  Mode = 1
  ModeName.Text = "Sinner"
  ModeName.TextStrokeColor3 = Color3.fromRGB(255,255,255)
  omgitskorn.OutlineColor = Color3.fromRGB(255,255,255)
  KillBot:Stop()
  Sinner:Play()
  att2.Parent = cplayer["Right Arm"]
  att2.Position = Vector3.new(-0.5, -3, -0.3)
  att2.Rotation = Vector3.new(35, 90, 0) --LavanderHair
 end
end)

while true do
   swait()
 sine = sine + change
 local torvel = (root.Velocity * Vector3.new(1, 0, 1)).magnitude
 local velderp = root.Velocity.y
 hitfloor, posfloor = rayCast(root.Position, CFrame.new(root.Position, root.Position - Vector3.new(0, 1, 0)).lookVector, 4* Player_Size, char)
  if 1 < root.Velocity.y and hitfloor == nil then
   Anim = "Jump"
   if attack == false and Mode == 1 then
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.5 - .5 * Cos(sine / 50)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3), Rad(0), Rad(25)), 0.15)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.5 - .5 * Cos(sine / 50), -.5* Player_Size) * LHCF * angles(Rad(-3), Rad(0), Rad(35)), 0.15)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, -0.1 + 0.1 * Sin(sine / 90)* Player_Size, 0* Player_Size) * angles(Rad(-65), Rad(-.6), Rad(0 + 10 * Sin(sine / 20))), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, -0.1 + 0.1 * Sin(sine / 90)* Player_Size, 0* Player_Size) * angles(Rad(5), Rad(-.6), Rad(-0 - 10 * Sin(sine / 20))), 0.1)
   elseif attack == false and Mode == 2 then
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.5 - .5 * Cos(sine / 50)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3), Rad(0), Rad(25)), 0.15)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.5 - .5 * Cos(sine / 50), -.5* Player_Size) * LHCF * angles(Rad(-3), Rad(0), Rad(35)), 0.15)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, -0.1 + 0.1 * Sin(sine / 90)* Player_Size, 0* Player_Size) * angles(Rad(-65), Rad(-.6), Rad(0 + 10 * Sin(sine / 20))), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, -0.1 + 0.1 * Sin(sine / 90)* Player_Size, 0* Player_Size) * angles(Rad(5), Rad(-.6), Rad(-0 - 10 * Sin(sine / 20))), 0.1)
   elseif attack == false and Mode == 3 then
       rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 3 + 0.5 * Cos(sine / 50)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25 - 15 * Sin(sine / 30)), Rad(0), Rad(0)), 1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.), Rad(0), Rad(0)), 0.15)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-.6), Rad(1 + 0 * Sin(sine / 20))), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-.6), Rad(-5 - 4.5 * Sin(sine / 20))), 0.1)
   elseif attack == false and Mode == 4 then
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 50)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.9 - 0.1 * Cos(sine / 50), -.5* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 90)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(90 + 10 * Sin(sine / 20))), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 90)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-0 - 10 * Sin(sine / 20))), 0.1)
   elseif attack == false and Mode == 5 then  
             rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(-16), Rad(0), Rad(0)), 0.15)
    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 2.5 * Sin(sine / 30)), Rad(0), Rad(0)), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -.2 - 0.1 * Cos(sine / 50)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.9 - 0.1 * Cos(sine / 50), -.5* Player_Size) * LHCF * angles(Rad(-2.5), Rad(0), Rad(0)), 0.15)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 90)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(30 + 10 * Sin(sine / 20))), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 90)* Player_Size, 0* Player_Size) * angles(Rad(25), Rad(-.6), Rad(-30 - 10 * Sin(sine / 20))), 0.1)
         end
         
  elseif -1 > root.Velocity.y and hitfloor == nil then
   Anim = "Fall"
   if attack == false and Mode == 1 then
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 10 * Sin(sine / 30)), Rad(0), Rad(0)), 1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.), Rad(0), Rad(0)), 0.15)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-.6), Rad(0 + 4.5 * Sin(sine / 20))), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-.6), Rad(-35 - 4.5 * Sin(sine / 20))), 0.1)
   elseif attack == false and Mode == 2 then
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 10 * Sin(sine / 30)), Rad(0), Rad(0)), 1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.), Rad(0), Rad(0)), 0.15)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-.6), Rad(0 + 4.5 * Sin(sine / 20))), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-.6), Rad(-35 - 4.5 * Sin(sine / 20))), 0.1)
   elseif attack == false and Mode == 3 then
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 3 + 0.5 * Cos(sine / 50)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(25 - 15 * Sin(sine / 30)), Rad(0), Rad(0)), 1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.), Rad(0), Rad(0)), 0.15)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-.6), Rad(1 + 0 * Sin(sine / 20))), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-.6), Rad(-5 - 4.5 * Sin(sine / 20))), 0.1)
   elseif attack == false and Mode == 4 then
          rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 1* Player_Size * Cos(sine / 12)) * angles(Rad(-10), Rad(0), Rad(0)), 0.1)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(5 * Sin(sine / -10)), Rad(0), math.random()), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.55 - 0.1 * Cos(sine / 50)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(90), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(0)), 0.1)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.6 - 0.2 * Cos(sine / 50)* Player_Size, -0.2* Player_Size) * angles(Rad(-40), Rad(-65), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.1)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.2 * Sin(sine / 50)* Player_Size, 1* Player_Size) * angles(Rad(-140), Rad(-4 + 6.5 * Sin(sine / 12)), Rad(-90)), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.2 + 0.1 * Sin(sine / 50)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(9 - 6.5 * Sin(sine / 12)), Rad(-15)), 0.1)
   elseif attack == false and Mode == 5 then  
             rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1 * Cos(sine / 20)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 10 * Sin(sine / 30)), Rad(0), Rad(0)), 1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.), Rad(0), Rad(0)), 0.15)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(190), Rad(-.6), Rad(45 + 4.5 * Sin(sine / 20))), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.02 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(190), Rad(-.6), Rad(-45 - 4.5 * Sin(sine / 20))), 0.1)
      end
     
  elseif torvel < 1 and hitfloor ~= nil then
   Anim = "Idle"
   change = 1
   if attack == false and Mode == 1 then  
   change  = 1
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0 + 0.05* Player_Size * Cos(sine / 12)) * angles(Rad(0), Rad(0), Rad(7)), 0.1)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(5 * Sin(sine / -16)), Rad(0), Rad(-10)), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - -0 * Cos(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(65), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(0)), 0.1)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -1 - -0 * Cos(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-75), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.1)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0 + 0 * Sin(sine / -30)* Player_Size, 0* Player_Size) * angles(Rad(125), Rad(6 + 6.5 * Sin(sine / 12)), Rad(-0)), 0.1)
    LW.C0 = clerp(LW.C0, CF(-0.5* Player_Size, 0 + 0 * Sin(sine / 30)* Player_Size, -0.5* Player_Size) * angles(Rad(0), Rad(6 - 6.5 * Sin(sine / 12)), Rad(90)), 0.1)
   elseif attack == false and Mode == 2 then
   change = 1
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 12)) * angles(Rad(0), Rad(0), Rad(7)), 0.1)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(2 * Sin(sine / -12)), Rad(0), Rad(-10)), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(0)), 0.1)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, -0.2* Player_Size) * angles(Rad(0), Rad(-65), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.1)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.1 * Sin(sine / -30)* Player_Size, 0* Player_Size) * angles(Rad(-75), Rad(6 + 6.5 * Sin(sine / 12)), Rad(-10)), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.2 + 0.1 * Sin(sine / 30)* Player_Size, -0* Player_Size) * angles(Rad(0), Rad(6 - 6.5 * Sin(sine / 12)), Rad(-10)), 0.1)
   elseif attack == false and Mode == 3 then
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 3 + 0.5 * Cos(sine / 50)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(1 - 15 * Sin(sine / 30)), Rad(0), Rad(0)), 1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.), Rad(0), Rad(0)), 0.15)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(0)), 0.15)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-.6), Rad(1 + 0 * Sin(sine / 20))), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(-.6), Rad(-5 - 4.5 * Sin(sine / 20))), 0.1)
   elseif attack == false and Mode == 4 then 
      rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 1* Player_Size * Cos(sine / 12)) * angles(Rad(-10), Rad(0), Rad(0)), 0.1)
      tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(5 * Sin(sine / -10)), Rad(0), math.random()), 0.1)
       RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.55 - 0.1 * Cos(sine / 50)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(50), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(0)), 0.1)
          LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.6 - 0.2 * Cos(sine / 50)* Player_Size, -0.2* Player_Size) * angles(Rad(-40), Rad(-65), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.1)
          RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.2 * Sin(sine / 50)* Player_Size, 1* Player_Size) * angles(Rad(-140), Rad(-4 + 6.5 * Sin(sine / 12)), Rad(-90)), 0.1)
       LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.2 + 0.1 * Sin(sine / 50)* Player_Size, 0* Player_Size) * angles(Rad(10), Rad(9 - 6.5 * Sin(sine / 12)), Rad(-15)), 0.1)
   elseif attack == false and Mode == 5 then  
      rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.1 + 0.1* Player_Size * Cos(sine / 12)) * angles(Rad(0), Rad(0), Rad(0)), 0.1)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(5 * Sin(sine / -10)), Rad(0), Rad(-20)), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0.1 * Cos(sine / 12)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(75), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(0)), 0.1)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 - 0.1 * Cos(sine / 100)* Player_Size, -0.2* Player_Size) * angles(Rad(10), Rad(-65), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.1)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.1 * Sin(sine / 50)* Player_Size, 0* Player_Size) * angles(Rad(0), Rad(6 + 6.5 * Sin(sine / 12)), Rad(0)), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.2 + 0.1 * Sin(sine / 50)* Player_Size, -0.5* Player_Size) * angles(Rad(190), Rad(6 - 6.5 * Sin(sine / 12)), Rad(45)), 0.1)
   end
   
  elseif torvel > 2 and torvel < 22 and hitfloor ~= nil then
   Anim = "Walk"
   if attack == false and Mode == 1 then
       change = 1
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.1 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-5), Rad(0), Rad(-0) - hed.RotVelocity.Y / 100), 0.15)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-20 - 20 * Cos(sine / 7)) - rl.RotVelocity.Y / 30 + -Sin(sine / 7) / 2, Rad(65 - 20 * Cos(sine / 7)), Rad(10)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5)
           LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 + 0 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-20 + 20 * Cos(sine / 7)) + ll.RotVelocity.Y / 30 + Sin(sine / 7) / 2.5, Rad(-65 - 20 * Cos(sine / 7)), Rad(10)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5) 
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.1 * Sin(sine / 100)* Player_Size, 0* Player_Size) * angles(Rad(90), Rad(6 + 6.5 * Sin(sine / 12)), Rad(30)), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0 + 0.0* Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-90)  * Cos(sine / 7) , Rad(90 * Cos(sine / 7)) , Rad(-6) + la.RotVelocity.Y / 90), 0.1)
              elseif attack == false and Mode == 2 then
               change = 1
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.1 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-5), Rad(0), Rad(-15) - hed.RotVelocity.Y / 100), 0.15)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-20 - 20 * Cos(sine / 7)) - rl.RotVelocity.Y / 360 + -Sin(sine / 7) / 2, Rad(65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5)
           LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 + 0 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-20 + 20 * Cos(sine / 7)) + ll.RotVelocity.Y / 360 + Sin(sine / 7) / 2.5, Rad(-65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5) 
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.1 * Sin(sine / 50)* Player_Size, 0* Player_Size) * angles(Rad(-60), Rad(6 + 6.5 * Sin(sine / 12)), Rad(0)), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0 + 0.0* Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-90)  * Cos(sine / 7) , Rad(35 * Cos(sine / 7)) , Rad(-6) + la.RotVelocity.Y / 90), 0.1)
              elseif attack == false and Mode == 3 then
               rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 3 + 1.5 * Cos(sine / 50)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 10 * Sin(sine / 30)), Rad(0), Rad(0)), 1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.), Rad(0), Rad(-35)), 0.15)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(15)), 0.15)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-0), Rad(-.6), Rad(15 + 4.5 * Sin(sine / 20))), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(90), Rad(-.6), Rad(-5 - 4.5 * Sin(sine / 20))), 0.1)
    elseif attack == false and Mode == 4 then  
          rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 1 + 1* Player_Size * Cos(sine / 12)) * angles(Rad(10), Rad(0), Rad(0)), 0.1)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(5 * Sin(sine / -10)), math.random(), Rad(0)), 0.1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.55 - 0.1 * Cos(sine / 50)* Player_Size, 0* Player_Size) * angles(Rad(-55), Rad(45), Rad(0)) * angles(Rad(-12.5), Rad(0), Rad(0)), 0.1)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.6 - 0.2 * Cos(sine / 50)* Player_Size, -0.2* Player_Size) * angles(Rad(-25), Rad(-75), Rad(0)) * angles(Rad(-6.5), Rad(0), Rad(6)), 0.1)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.2 * Sin(sine / 50)* Player_Size, 1* Player_Size) * angles(Rad(-90), Rad(-4 + 6.5 * Sin(sine / 12)), Rad(-90)), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.2 + 0.1 * Sin(sine / 50)* Player_Size, 0* Player_Size) * angles(Rad(45), Rad(9 - 6.5 * Sin(sine / 12)), Rad(-15)), 0.1)
   elseif attack == false and Mode == 5 then  
       rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.1 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-5), Rad(0), Rad(-15) - hed.RotVelocity.Y / 100), 0.15)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-20 - 20 * Cos(sine / 7)) - rl.RotVelocity.Y / 360 + -Sin(sine / 7) / 2.5, Rad(65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5)
           LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-20 + 20 * Cos(sine / 7)) + ll.RotVelocity.Y / 360 + Sin(sine / 7) / 2.5, Rad(-65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5)  
     RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(120)  * Cos(sine / 7) , Rad(9 * Cos(sine / 7)), Rad(6) - ra.RotVelocity.Y / 90), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-120)  * Cos(sine / 7) , Rad(0 * Cos(sine / 7)) , Rad(-6) + la.RotVelocity.Y / 90), 0.1)
   end
  elseif torvel >= 22 and hitfloor ~= nil then
   Anim = "Sprint"
    change = 1.35
   if attack == false and Mode == 1 then
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.1 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-5), Rad(0), Rad(-15) - hed.RotVelocity.Y / 100), 0.15)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-50 - 50 * Cos(sine / 7)) - rl.RotVelocity.Y / 360 + -Sin(sine / 7) / 2, Rad(65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5)
           LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 + 0 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-50 + 20 * Cos(sine / 7)) + ll.RotVelocity.Y / 360 + Sin(sine / 7) / 2.5, Rad(-65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5) 
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.1 * Sin(sine / 50)* Player_Size, 0* Player_Size) * angles(Rad(90), Rad(6 + 6.5 * Sin(sine / 12)), Rad(0)), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0 + 0.0* Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-90)  * Cos(sine / 7) , Rad(35 * Cos(sine / 7)) , Rad(-6) + la.RotVelocity.Y / 90), 0.1)
     elseif attack == false and Mode == 2 then
               change = 1
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.1 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-5), Rad(0), Rad(-15) - hed.RotVelocity.Y / 100), 0.15)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.9 - 0 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-20 - 20 * Cos(sine / 7)) - rl.RotVelocity.Y / 360 + -Sin(sine / 7) / 2, Rad(65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5)
           LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.9 + 0 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-20 + 20 * Cos(sine / 7)) + ll.RotVelocity.Y / 360 + Sin(sine / 7) / 2.5, Rad(-65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5) 
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.2 + 0.1 * Sin(sine / 50)* Player_Size, 0* Player_Size) * angles(Rad(-60), Rad(6 + 6.5 * Sin(sine / 12)), Rad(0)), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0 + 0.0* Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-90)  * Cos(sine / 7) , Rad(35 * Cos(sine / 7)) , Rad(-6) + la.RotVelocity.Y / 90), 0.1)
   elseif attack == false and Mode == 3 then
   -- copy and pasted my walk cause i didnt see a reason to make a sprint, fall or jump on mode 3
    rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, 3 + 1.5 * Cos(sine / 50)* Player_Size) * angles(Rad(24), Rad(0), Rad(0)), 0.15)
    neck.C0 = clerp(neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(10 - 10 * Sin(sine / 30)), Rad(0), Rad(0)), 1)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -1 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * RHCF * angles(Rad(-3.), Rad(0), Rad(-35)), 0.15)
    LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -.8 - 0.1 * Cos(sine / 20)* Player_Size, -.3* Player_Size) * LHCF * angles(Rad(-3.5), Rad(0), Rad(15)), 0.15)
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(-0), Rad(-.6), Rad(15 + 4.5 * Sin(sine / 20))), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.1 * Sin(sine / 20)* Player_Size, 0* Player_Size) * angles(Rad(90), Rad(-.6), Rad(-5 - 4.5 * Sin(sine / 20))), 0.1)
     elseif attack == false and Mode == 4 then  
          rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.1 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-5), Rad(0), Rad(-10) - hed.RotVelocity.Y / 100), 0.15)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-20 - 20 * Cos(sine / 7)) - rl.RotVelocity.Y / 360 + -Sin(sine / 7) / 2, Rad(65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5)
           LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-20 + 20 * Cos(sine / 7)) + ll.RotVelocity.Y / 360 + Sin(sine / 7) / 2.5, Rad(-65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5) 
    RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(0)  * Cos(sine / 7) , Rad(9 * Cos(sine / 7)), Rad(6) - ra.RotVelocity.Y / 90), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-90)  * Cos(sine / 7) , Rad(0 * Cos(sine / 7)) , Rad(-6) + la.RotVelocity.Y / 90), 0.1)
     elseif attack == false and Mode == 5 then  
                rootj.C0 = clerp(rootj.C0, RootCF * CF(0* Player_Size, 0* Player_Size, -0.175 + 0.1 * Cos(sine / 3.5) + -Sin(sine / 3.5) / 7* Player_Size) * angles(Rad(3 - 2.5 * Cos(sine / 3.5)), Rad(0) - root.RotVelocity.Y / 75, Rad(8 * Cos(sine / 7))), 0.15)
    tors.Neck.C0 = clerp(tors.Neck.C0, necko* CF(0, 0, 0 + ((1* Player_Size) - 1)) * angles(Rad(-5), Rad(0), Rad(-15) - hed.RotVelocity.Y / 100), 0.15)
    RH.C0 = clerp(RH.C0, CF(1* Player_Size, -0.8 - 0.5 * Cos(sine / 7) / 2* Player_Size, 0.6 * Cos(sine / 7) / 2* Player_Size)  * angles(Rad(-20 - 20 * Cos(sine / 7)) - rl.RotVelocity.Y / 360 + -Sin(sine / 7) / 2.5, Rad(65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 + 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5)
           LH.C0 = clerp(LH.C0, CF(-1* Player_Size, -0.8 + 0.5 * Cos(sine / 7) / 2* Player_Size, -0.6 * Cos(sine / 7) / 2* Player_Size) * angles(Rad(-20 + 20 * Cos(sine / 7)) + ll.RotVelocity.Y / 360 + Sin(sine / 7) / 2.5, Rad(-65 - 10 * Cos(sine / 7)), Rad(0)) * angles(Rad(0 - 2 * Cos(sine / 7)), Rad(0), Rad(0)), 0.5) 
     RW.C0 = clerp(RW.C0, CF(1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(120)  * Cos(sine / 7) , Rad(9 * Cos(sine / 7)), Rad(6) - ra.RotVelocity.Y / 90), 0.1)
    LW.C0 = clerp(LW.C0, CF(-1.5* Player_Size, 0.5 + 0.05 * Sin(sine / 7)* Player_Size, 0* Player_Size) * angles(Rad(-120)  * Cos(sine / 7) , Rad(0 * Cos(sine / 7)) , Rad(-6) + la.RotVelocity.Y / 90), 0.1) 
             end
          end
       end
-------------------------------------------------------
--End Animations And Script--
-------------------------------------------------------
 
