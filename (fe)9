game.Players.LocalPlayer.Character.Head.Anch = true
game.TestService.IsSleepAllowed = false

for i,v in next, game:GetService("Players").LocalPlayer.Character:GetDescendants() do
	if v:IsA("BasePart") then 
		game:GetService("RunService").Heartbeat:connect(function()
			v.Velocity = Vector3.new(-40,0,-10)
			pcall(function()
				v.CanCollide = false
			end)
			pcall(function()
				v.CanQuery = false
			end)
		end)
	end
end

local hatnameclone = {}
for _,v in next, game:FindFirstChildOfClass("Players").LocalPlayer["Character"]:GetChildren() do
	if v:IsA("Accessory") then
		if hatnameclone[v.Name] then
			if hatnameclone[v.Name] == "s" then
				hatnameclone[v.Name] = {}
			end
			table.insert(hatnameclone[v.Name],v)
		else
			hatnameclone[v.Name] = "s"
		end
	end
end
for _,v in pairs(hatnameclone) do
	if type(v) == "table" then
		local num = 1
		for _,w in pairs(v) do
			w.Name = w.Name..num
			num = num + 1
		end
	end
end
hatnameclone = nil

local v3_net, v3_808 = Vector3.new(5000, 25.1, 0), Vector3.new(8, 0, 8)
    local function getNetlessVelocity(realPartVelocity)
        local mag = realPartVelocity.Magnitude
        if mag > 1 then
            local unit = realPartVelocity.Unit
            if (unit.Y > 0.25) or (unit.Y < -0.75) then
                return unit * (25.1 / unit.Y)
            end
        end
        return v3_net + realPartVelocity * v3_808
    end
local simradius = "shp" --simulation radius (net bypass) method
--simulation radius (net bypass) method
--"shp" - sethiddenproperty
--"ssr" - setsimulationradius
--false - disable
local antiragdoll = true --removes hingeConstraints and ballSocketConstraints from your character
local newanimate = true --disables the animate script and enables after reanimation
local discharscripts = true --disables all localScripts parented to your character before reanimation
local R15toR6 = true --tries to convert your character to r6 if its r15
local hatcollide = true --makes hats cancollide (only method 0)
local humState16 = true --enables collisions for limbs before the humanoid dies (using hum:ChangeState)
local addtools = false --puts all tools from backpack to character and lets you hold them after reanimation
local hedafterneck = false --disable aligns for head and enable after neck is removed
local loadtime = game:GetService("Players").RespawnTime + 0.5 --anti respawn delay
local method = 0 --reanimation method
--methods:
--0 - breakJoints (takes [loadtime] seconds to laod)
--1 - limbs
--2 - limbs + anti respawn
--3 - limbs + breakJoints after [loadtime] seconds
--4 - remove humanoid + breakJoints
--5 - remove humanoid + limbs
local alignmode = 3 --AlignPosition mode
--modes:
--1 - AlignPosition rigidity enabled true
--2 - 2 AlignPositions rigidity enabled both true and false
--3 - AlignPosition rigidity enabled false

healthHide = healthHide and ((method == 0) or (method == 2) or (method == 000)) and gp(c, "Head", "BasePart")

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = v3(0, 0, 0)
local inf = math.huge

local c = lp.Character

if not (c and c.Parent) then
	return
end

c.Destroying:Connect(function()
	c = nil
end)

local function gp(parent, name, className)
	if typeof(parent) == "Instance" then
		for i, v in pairs(parent:GetChildren()) do
			if (v.Name == name) and v:IsA(className) then
				return v
			end
		end
	end
	return nil
end

local function align(Part0, Part1)
	Part0.CustomPhysicalProperties = PhysicalProperties.new(0.0001, 0.0001, 0.0001, 0.0001, 0.0001)

	local att0 = Instance.new("Attachment", Part0)
	att0.Orientation = v3_0
	att0.Position = v3_0
	att0.Name = "att0_" .. Part0.Name
	local att1 = Instance.new("Attachment", Part1)
	att1.Orientation = v3_0
	att1.Position = v3_0
	att1.Name = "att1_" .. Part1.Name

	if (alignmode == 1) or (alignmode == 2) then
		local ape = Instance.new("AlignPosition", att0)
		ape.ApplyAtCenterOfMass = false
		ape.MaxForce = inf
		ape.MaxVelocity = inf
		ape.ReactionForceEnabled = false
		ape.Responsiveness = 200
		ape.Attachment1 = att1
		ape.Attachment0 = att0
		ape.Name = "AlignPositionRtrue"
		ape.RigidityEnabled = true
	end

	if (alignmode == 2) or (alignmode == 3) then
		local apd = Instance.new("AlignPosition", att0)
		apd.ApplyAtCenterOfMass = false
		apd.MaxForce = inf
		apd.MaxVelocity = inf
		apd.ReactionForceEnabled = false
		apd.Responsiveness = 200
		apd.Attachment1 = att1
		apd.Attachment0 = att0
		apd.Name = "AlignPositionRfalse"
		apd.RigidityEnabled = false
	end

	local ao = Instance.new("AlignOrientation", att0)
	ao.MaxAngularVelocity = inf
	ao.MaxTorque = inf
	ao.PrimaryAxisOnly = false
	ao.ReactionTorqueEnabled = false
	ao.Responsiveness = 200
	ao.Attachment1 = att1
	ao.Attachment0 = att0
	ao.RigidityEnabled = false

	if type(getNetlessVelocity) == "function" then
	    local realVelocity = v3_0
        local steppedcon = stepped:Connect(function()
            Part0.Velocity = realVelocity
        end)
        local heartbeatcon = heartbeat:Connect(function()
            realVelocity = Part0.Velocity
            Part0.Velocity = getNetlessVelocity(realVelocity)
        end)
        Part0.Destroying:Connect(function()
            Part0 = nil
            steppedcon:Disconnect()
            heartbeatcon:Disconnect()
        end)
    end
end

local function respawnrequest()
	local ccfr = ws.CurrentCamera.CFrame
	local c = lp.Character
	lp.Character = nil
	lp.Character = c
	local con = nil
	con = ws.CurrentCamera.Changed:Connect(function(prop)
	    if (prop ~= "Parent") and (prop ~= "CFrame") then
	        return
	    end
	    ws.CurrentCamera.CFrame = ccfr
	    con:Disconnect()
    end)
end

local destroyhum = (method == 4) or (method == 5)
local breakjoints = (method == 0) or (method == 4)
local antirespawn = (method == 0) or (method == 2) or (method == 3)

hatcollide = hatcollide and (method == 0)

addtools = addtools and gp(lp, "Backpack", "Backpack")

local fenv = getfenv()
local shp = fenv.sethiddenproperty or fenv.set_hidden_property or fenv.set_hidden_prop or fenv.sethiddenprop
local ssr = fenv.setsimulationradius or fenv.set_simulation_radius or fenv.set_sim_radius or fenv.setsimradius or fenv.set_simulation_rad or fenv.setsimulationrad

if shp and (simradius == "shp") then
	spawn(function()
		while c and heartbeat:Wait() do
			shp(lp, "SimulationRadius", inf)
		end
	end)
elseif ssr and (simradius == "ssr") then
	spawn(function()
		while c and heartbeat:Wait() do
			ssr(inf)
		end
	end)
end

antiragdoll = antiragdoll and function(v)
	if v:IsA("HingeConstraint") or v:IsA("BallSocketConstraint") then
		v.Parent = nil
	end
end

if antiragdoll then
	for i, v in pairs(c:GetDescendants()) do
		antiragdoll(v)
	end
	c.DescendantAdded:Connect(antiragdoll)
end

if antirespawn then
	respawnrequest()
end

if method == 0 then
	wait(loadtime)
	if not c then
		return
	end
end

if discharscripts then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("LocalScript") then
			v.Disabled = true
		end
	end
elseif newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate and (not animate.Disabled) then
		animate.Disabled = true
	else
		newanimate = false
	end
end

if addtools then
	for i, v in pairs(addtools:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = c
		end
	end
end

pcall(function()
	settings().Physics.AllowSleep = false
	settings().Physics.PhysicsEnvironmentalThrottle = Enum.EnviromentalPhysicsThrottle.Disabled
end)

local OLDscripts = {}

for i, v in pairs(c:GetDescendants()) do
	if v.ClassName == "Script" then
		table.insert(OLDscripts, v)
	end
end

local scriptNames = {}

for i, v in pairs(c:GetDescendants()) do
	if v:IsA("BasePart") then
		local newName = tostring(i)
		local exists = true
		while exists do
			exists = false
			for i, v in pairs(OLDscripts) do
				if v.Name == newName then
					exists = true
				end
			end
			if exists then
				newName = newName .. "_"    
			end
		end
		table.insert(scriptNames, newName)
		Instance.new("Script", v).Name = newName
	end
end

c.Archivable = true
local hum = c:FindFirstChildOfClass("Humanoid")
if hum then
	for i, v in pairs(hum:GetPlayingAnimationTracks()) do
		v:Stop()
	end
end
local cl = c:Clone()
if hum and humState16 then
    hum:ChangeState(Enum.HumanoidStateType.Physics)
    if destroyhum then
        wait(1.6)
    end
end
if hum and hum.Parent and destroyhum then
    hum:Destroy()
end

if not c then
    return
end

local head = gp(c, "Head", "BasePart")
local torso = gp(c, "Torso", "BasePart") or gp(c, "UpperTorso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")
if hatcollide and c:FindFirstChildOfClass("Tool") then
    local anything = c:FindFirstChildOfClass("BodyColors") or gp(c, "Health", "Script")
    if not (torso and root and anything) then
        return
    end
    --torso:Destroy()
    --root:Destroy()
    if shp then
        for i,v in pairs(c:GetChildren()) do
            if v:IsA("Tools") then
                shp(v, "BackendAccoutrementState", 0)
            end 
        end
    end
    --anything:Destroy()
    if head then
        
    end
end

for i, v in pairs(cl:GetDescendants()) do
	if v:IsA("BasePart") then
		v.Transparency = 1
		v.Anchored = false
	end
end

local model = Instance.new("Model", c)
model.Name = model.ClassName

model.Destroying:Connect(function()
	model = nil
end)

for i, v in pairs(c:GetChildren()) do
	if v ~= model then
		if addtools and v:IsA("Tool") then
			for i1, v1 in pairs(v:GetDescendants()) do
				if v1 and v1.Parent and v1:IsA("BasePart") then
					local bv = Instance.new("BodyVelocity", v1)
					bv.Velocity = v3_0
					bv.MaxForce = v3(1000, 1000, 1000)
					bv.P = 1250
					bv.Name = "bv_" .. v.Name
				end
			end
		end
		v.Parent = model
	end
end

if breakjoints then
	model:BreakJoints()
else
	if head and torso then
		for i, v in pairs(model:GetDescendants()) do
			if v:IsA("Weld") or v:IsA("Snap") or v:IsA("Glue") or v:IsA("Motor") or v:IsA("Motor6D") then
				local save = false
				if (v.Part0 == torso) and (v.Part1 == head) then
					save = true
				end
				if (v.Part0 == head) and (v.Part1 == torso) then
					save = true
				end
				if save then
					if hedafterneck then
						hedafterneck = v
					end
				else
					v:Destroy()
				end
			end
		end
	end
	if method == 3 then
		spawn(function()
			wait(loadtime)
			if model then
				model:BreakJoints()
			end
		end)
	end
end

cl.Parent = c
for i, v in pairs(cl:GetChildren()) do
	v.Parent = c
end
cl:Destroy()

local modelDes = {}
for i, v in pairs(model:GetDescendants()) do
	if v:IsA("BasePart") then
		i = tostring(i)
		v.Destroying:Connect(function()
			modelDes[i] = nil
		end)
		modelDes[i] = v
	end
end
local modelcolcon = nil
local function modelcolf()
	if model then
		for i, v in pairs(modelDes) do
			v.CanCollide = false
		end
	else
		modelcolcon:Disconnect()
	end
end
modelcolcon = stepped:Connect(modelcolf)
modelcolf()

for i, scr in pairs(model:GetDescendants()) do
	if (scr.ClassName == "Script") and table.find(scriptNames, scr.Name) then
		local Part0 = scr.Parent
		if Part0:IsA("BasePart") then
			for i1, scr1 in pairs(c:GetDescendants()) do
				if (scr1.ClassName == "Script") and (scr1.Name == scr.Name) and (not scr1:IsDescendantOf(model)) then
					local Part1 = scr1.Parent
					if (Part1.ClassName == Part0.ClassName) and (Part1.Name == Part0.Name) then
						align(Part0, Part1)
						break
					end
				end
			end
		end
	end
end

if (typeof(hedafterneck) == "Instance") and head then
	local aligns = {}
	local con = nil
	con = hedafterneck.Changed:Connect(function(prop)
	    if (prop == "Parent") and not hedafterneck.Parent then
	        con:Disconnect()
    		for i, v in pairs(aligns) do
    			v.Enabled = true
    		end
		end
	end)
	for i, v in pairs(head:GetDescendants()) do
		if v:IsA("AlignPosition") or v:IsA("AlignOrientation") then
			i = tostring(i)
			aligns[i] = v
			v.Destroying:Connect(function()
			    aligns[i] = nil
			end)
			v.Enabled = false
		end
	end
end

for i, v in pairs(c:GetDescendants()) do
	if v and v.Parent then
		if v.ClassName == "Script" then
			if table.find(scriptNames, v.Name) then
				v:Destroy()
			end
		elseif not v:IsDescendantOf(model) then
			if v:IsA("Decal") then
				v.Transparency = 1
			elseif v:IsA("ForceField") then
				v.Visible = false
			elseif v:IsA("Sound") then
				v.Playing = false
			elseif v:IsA("BillboardGui") or v:IsA("SurfaceGui") or v:IsA("ParticleEmitter") or v:IsA("Fire") or v:IsA("Smoke") or v:IsA("Sparkles") then
				v.Enabled = false
			end
		end
	end
end

if newanimate then
	local animate = gp(c, "Animate", "LocalScript")
	if animate then
		animate.Disabled = false
	end
end

if addtools then
	for i, v in pairs(c:GetChildren()) do
		if v:IsA("Tool") then
			v.Parent = addtools
		end
	end
end

local hum0 = model:FindFirstChildOfClass("Humanoid")
if hum0 then
    hum0.Destroying:Connect(function()
        hum0 = nil
    end)
end

local hum1 = c:FindFirstChildOfClass("Humanoid")
if hum1 then
    hum1.Destroying:Connect(function()
        hum1 = nil
    end)
end

if hum1 then
	ws.CurrentCamera.CameraSubject = hum1
	local camSubCon = nil
	local function camSubFunc()
		camSubCon:Disconnect()
		if c and hum1 then
			ws.CurrentCamera.CameraSubject = hum1
		end
	end
	camSubCon = renderstepped:Connect(camSubFunc)
	if hum0 then
		hum0.Changed:Connect(function(prop)
			if hum1 and (prop == "Jump") then
				hum1.Jump = hum0.Jump
			end
		end)
	else
		respawnrequest()
	end
end

local rb = Instance.new("BindableEvent", c)
rb.Event:Connect(function()
	rb:Destroy()
	sg:SetCore("ResetButtonCallback", true)
	if destroyhum then
		c:BreakJoints()
		return
	end
	if hum0 and (hum0.Health > 0) then
		model:BreakJoints()
		hum0.Health = 0
	end
	if antirespawn then
	    respawnrequest()
	end
end)
sg:SetCore("ResetButtonCallback", rb)

spawn(function()
	while c do
		if hum0 and hum1 then
			hum1.Jump = hum0.Jump
		end
		wait()
	end
	sg:SetCore("ResetButtonCallback", true)
end)

R15toR6 = R15toR6 and hum1 and (hum1.RigType == Enum.HumanoidRigType.R15)
if R15toR6 then
    local part = gp(c, "HumanoidRootPart", "BasePart") or gp(c, "UpperTorso", "BasePart") or gp(c, "LowerTorso", "BasePart") or gp(c, "Head", "BasePart") or c:FindFirstChildWhichIsA("BasePart")
	if part then
	    local cfr = part.CFrame
		local R6parts = { 
			head = {
				Name = "Head",
				Size = v3(2, 1, 1),
				R15 = {
					Head = 0
				}
			},
			torso = {
				Name = "Torso",
				Size = v3(2, 2, 1),
				R15 = {
					UpperTorso = 0.2,
					LowerTorso = -0.7
				}
			},
			root = {
				Name = "HumanoidRootPart",
				Size = v3(2, 2, 1),
				R15 = {
					HumanoidRootPart = 0
				}
			},
			leftArm = {
				Name = "Left Arm",
				Size = v3(1, 2, 1),
				R15 = {
					LeftHand = -0.7,
					LeftLowerArm = -0.2,
					LeftUpperArm = 0.4
				}
			},
			rightArm = {
				Name = "Right Arm",
				Size = v3(1, 2, 1),
				R15 = {
					RightHand = -0.7,
					RightLowerArm = -0.2,
					RightUpperArm = 0.4
				}
			},
			leftLeg = {
				Name = "Left Leg",
				Size = v3(1, 2, 1),
				R15 = {
					LeftFoot = -0.7,
					LeftLowerLeg = -0.15,
					LeftUpperLeg = 0.6
				}
			},
			rightLeg = {
				Name = "Right Leg",
				Size = v3(1, 2, 1),
				R15 = {
					RightFoot = -0.7,
					RightLowerLeg = -0.15,
					RightUpperLeg = 0.6
				}
			}
		}
		for i, v in pairs(c:GetChildren()) do
			if v:IsA("BasePart") then
				for i1, v1 in pairs(v:GetChildren()) do
					if v1:IsA("Motor6D") then
						v1.Part0 = nil
					end
				end
			end
		end
		part.Archivable = true
		for i, v in pairs(R6parts) do
			local part = part:Clone()
			part:ClearAllChildren()
			part.Name = v.Name
			part.Size = v.Size
			part.CFrame = cfr
			part.Anchored = false
			part.Transparency = 1
			part.CanCollide = false
			for i1, v1 in pairs(v.R15) do
				local R15part = gp(c, i1, "BasePart")
				local att = gp(R15part, "att1_" .. i1, "Attachment")
				if R15part then
					local weld = Instance.new("Weld", R15part)
					weld.Name = "Weld_" .. i1
					weld.Part0 = part
					weld.Part1 = R15part
					weld.C0 = cf(0, v1, 0)
					weld.C1 = cf(0, 0, 0)
					R15part.Massless = true
					R15part.Name = "R15_" .. i1
					R15part.Parent = part
					if att then
						att.Parent = part
						att.Position = v3(0, v1, 0)
					end
				end
			end
			part.Parent = c
			R6parts[i] = part
		end
		local R6joints = {
			neck = {
				Parent = R6parts.torso,
				Name = "Neck",
				Part0 = R6parts.torso,
				Part1 = R6parts.head,
				C0 = cf(0, 1, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, -0.5, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rootJoint = {
				Parent = R6parts.root,
				Name = "RootJoint" ,
				Part0 = R6parts.root,
				Part1 = R6parts.torso,
				C0 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0),
				C1 = cf(0, 0, 0, -1, 0, 0, 0, 0, 1, 0, 1, -0)
			},
			rightShoulder = {
				Parent = R6parts.torso,
				Name = "Right Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightArm,
				C0 = cf(1, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(-0.5, 0.5, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftShoulder = {
				Parent = R6parts.torso,
				Name = "Left Shoulder",
				Part0 = R6parts.torso,
				Part1 = R6parts.leftArm,
				C0 = cf(-1, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(0.5, 0.5, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			},
			rightHip = {
				Parent = R6parts.torso,
				Name = "Right Hip",
				Part0 = R6parts.torso,
				Part1 = R6parts.rightLeg,
				C0 = cf(1, -1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0),
				C1 = cf(0.5, 1, 0, 0, 0, 1, 0, 1, -0, -1, 0, 0)
			},
			leftHip = {
				Parent = R6parts.torso,
				Name = "Left Hip" ,
				Part0 = R6parts.torso,
				Part1 = R6parts.leftLeg,
				C0 = cf(-1, -1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0),
				C1 = cf(-0.5, 1, 0, 0, 0, -1, 0, 1, 0, 1, 0, 0)
			}
		}
		for i, v in pairs(R6joints) do
			local joint = Instance.new("Motor6D")
			for prop, val in pairs(v) do
				joint[prop] = val
			end
			R6joints[i] = joint
		end
		hum1.RigType = Enum.HumanoidRigType.R6
		hum1.HipHeight = 0
	end
end

local v = "Tool"


--find rig joints

local function fakemotor()
    return {C0=cf(), C1=cf()}
end

local torso = gp(c, "Torso", "BasePart")
local root = gp(c, "HumanoidRootPart", "BasePart")

local neck = gp(torso, "Neck", "Motor6D")
neck = neck or fakemotor()

local rootJoint = gp(root, "RootJoint", "Motor6D")
rootJoint = rootJoint or fakemotor()

local leftShoulder = gp(torso, "Left Shoulder", "Motor6D")
leftShoulder = leftShoulder or fakemotor()

local rightShoulder = gp(torso, "Right Shoulder", "Motor6D")
rightShoulder = rightShoulder or fakemotor()

local leftHip = gp(torso, "Left Hip", "Motor6D")
leftHip = leftHip or fakemotor()

local rightHip = gp(torso, "Right Hip", "Motor6D")
rightHip = rightHip or fakemotor()

--120 fps

local fps = 60
local event = Instance.new("BindableEvent", c)
event.Name = "120 fps"
local floor = math.floor
fps = 1 / fps
local tf = 0
local con = nil
con = game:GetService("RunService").RenderStepped:Connect(function(s)
	if not c then
		con:Disconnect()
		return
	end
    --tf += s
	if tf >= fps then
		for i=1, floor(tf / fps) do
			event:Fire(c)
		end
		tf = 0
	end
end)
local event = event.Event

local hedrot = v3(0, 5, 0)

local uis = game:GetService("UserInputService")
local function isPressed(key)
    return (not uis:GetFocusedTextBox()) and uis:IsKeyDown(Enum.KeyCode[key])
end

local biggesthandle = nil
for i, v in pairs(c:GetChildren()) do
    if v:IsA("Tool") then
        local handle = gp(v, "Handle", "BasePart")
        if biggesthandle then
            if biggesthandle.Size.Magnitude < handle.Size.Magnitude then
                biggesthandle = handle
            end
        else
            biggesthandle = gp(v, "Handle", "BasePart")
        end
    end
end

if not biggesthandle then
    return
end

local handle1 = gp(gp(model, biggesthandle.Parent.Name, "Tool"), "Handle", "BasePart")
if not handle1 then
    return
end

handle1.Destroying:Connect(function()
    handle1 = nil
end)
biggesthandle.Destroying:Connect(function()
    biggesthandle = nil
end)

biggesthandle:BreakJoints()
biggesthandle.Anchored = true

for i, v in pairs(handle1:GetDescendants()) do
    if v:IsA("AlignOrientation") then
        v.Enabled = false
    end
end

local mouse = lp:GetMouse()
local fling = false
mouse.Button1Down:Connect(function()
fling = true
end)

mouse.Button1Up:Connect(function()
    fling = false
end)

omgHuman = game.Players.LocalPlayer.Character.HumanoidRootPart
UselessPartLmao = Instance.new("Part", omgHuman)
UselessPartLmao.Name = "life fucking sucks and i wanna jump off a bridge"
UselessPartLmao.CanCollide = false
UselessPartLmao.Transparency = 1

well = Instance.new("Weld", UselessPartLmao)
well.Name = "Lois family guy"
well.Part0 = UselessPartLmao
well.Part1 = omgHuman
well.C0 = cf(0, 12.5, 0)
well.C1 = cf(0, 0, 0)

local function doForSignal(signal, vel)
    spawn(function()
        while signal:Wait() and c and handle1 and biggesthandle do
            if fling == true and mouse.Target then
                biggesthandle.Position = mouse.Hit.Position
               
            end
            if fling == false then
                biggesthandle.Position = UselessPartLmao.Position

            end
            handle1.RotVelocity = Vector3.new(9999999,9999999,9999999)
        end
    end)
end
doForSignal(stepped, v3(0, 0, 0))
doForSignal(renderstepped, v3(0, 0, 0))
doForSignal(heartbeat, v3(200000000000000000000000000000, 200000000000000000000000000000, 200000000000000000000000000000))
--Hat1

local lp = game:GetService("Players").LocalPlayer
local rs = game:GetService("RunService")
local stepped = rs.Stepped
local heartbeat = rs.Heartbeat
local renderstepped = rs.RenderStepped
local sg = game:GetService("StarterGui")
local ws = game:GetService("Workspace")
local cf = CFrame.new
local v3 = Vector3.new
local v3_0 = Vector3.zero
local inf = math.huge

local cplayer = lp.Character

local v3 = Vector3.new

local function gp(parent, name, className)
    if typeof(parent) == "Instance" then
        for i, v in pairs(parent:GetChildren()) do
            if (v.Name == name) and v:IsA(className) then
                return v
            end
        end
    end
    return nil
end

for i,v in pairs (cplayer:GetChildren()) do
	if v:IsA("Accessory") then
		v.Handle.Massless = true
		v.Handle.CustomPhysicalProperties = PhysicalProperties.new(0,0,0,0,0)
	end
end

game.Players.LocalPlayer.Character.Head.Anchored = false

local hat2 = gp(cplayer, "Front", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Torso"] --any part of humanoid
att2.Position = Vector3.new(-0, 0, 0)
att2.Rotation = Vector3.new(0, 0, -0)--you can delete this 


local hat2 = gp(cplayer, "ArmTool", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Left Arm"]
att2.Position = Vector3.new(-0, -0, -0)
att2.Rotation = Vector3.new(-90, -0, 90)

local hat2 = gp(cplayer, "Yellow unloaded head", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Right Arm"]
att2.Position = Vector3.new(-0, -0, 0)
att2.Rotation = Vector3.new(90, -90, -0) --LavanderHair

local hat2 = gp(cplayer, "Unloaded head", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Right Leg"]
att2.Position = Vector3.new(-0, -0, 0) --Robloxclassicred
att2.Rotation = Vector3.new(90, -90, 0)

local hat2 = gp(cplayer, "Leg", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = cplayer["Left Leg"]
att2.Position = Vector3.new(-0, -0, 0)
att2.Rotation = Vector3.new(90, 90, 0)


local script = game:GetObjects("rbxassetid://10170990440")[1]
	local AHB = Instance.new("BindableEvent")
	
	local FPS = 30
	
	local TimeFrame = 0
	
	local LastFrame = tick()
	local Frame = 1/FPS
	
	game:service'RunService'.Heartbeat:connect(function(s,p)
		TimeFrame = TimeFrame + s
		if(TimeFrame >= Frame)then
			for i = 1,math.floor(TimeFrame/Frame) do
				AHB:Fire()
			end
			LastFrame=tick()
			TimeFrame=TimeFrame-Frame*math.floor(TimeFrame/Frame)
		end
	end)


	function swait(dur)
		if(dur == 0 or typeof(dur) ~= 'number')then
			AHB.Event:wait()
		else
			for i = 1, dur*FPS do
				AHB.Event:wait()
			end
		end
	end

--made by helkern	
wait(1/60)	
player = game:GetService("Players").LocalPlayer
mouse = player:GetMouse()
character = player.Character
playergui = player.PlayerGui

humanoid = character.Humanoid
rootpart = character.HumanoidRootPart
head = character.Head
torso = character.Torso
rightarm = character["Right Arm"]
leftarm = character["Left Arm"]
rightleg = character["Right Leg"]
leftleg = character["Left Leg"]

rootjoint = rootpart.RootJoint
neck = torso.Neck
rightshoulder = torso["Right Shoulder"]
leftshoulder = torso["Left Shoulder"]
righthip = torso["Right Hip"]
lefthip = torso["Left Hip"]


song = Instance.new("Sound",torso)

cf = CFrame.new
d = cf(0,0,0)
vt = Vector3.new
random = math.random
cos = math.cos
sin = math.sin
rad = math.rad
angles = CFrame.Angles

tweenservice = game:GetService("TweenService")
debris = game:GetService("Debris")

sine = 0
mousehold,keyhold = false,false
rooted = false
attack = false
rootc0 = cf(0, 0, 0) * angles(rad(-90), rad(0), rad(180))
neckc0 = cf(0, 1, 0) * angles(rad(-90), rad(0), rad(180))
change = 1
effects = Instance.new("Folder",character)
effects.Name = "effects lol"
if humanoid.Animator then humanoid.Animator:Destroy() end
anim = "idle"

ArtificialHB = Instance.new("BindableEvent", script)
ArtificialHB.Name = "ArtificialHB"
script:WaitForChild("ArtificialHB")
frame = 1/60
tf = 0
allowframeloss = false
tossremainder = false
lastframe = tick()
script.ArtificialHB:Fire()
game:GetService("RunService").Heartbeat:connect(function(s, p)
	tf = tf + s
	if tf >= frame then
		if allowframeloss then
			script.ArtificialHB:Fire()
			lastframe = tick()
		else
			for i = 1, math.floor(tf / frame) do
				script.ArtificialHB:Fire()
			end
		lastframe = tick()
		end
		if tossremainder then
			tf = 0
		else
			tf = tf - frame * math.floor(tf / frame)
		end
	end
end)


function Swait(n)
	if n == 0 or n == nil then
		ArtificialHB.Event:wait()
	else
		for i = 1, n do
			ArtificialHB.Event:wait()
		end
	end
end

function part(parent, mat, transp, color, size, anchored, shape)
	local p = Instance.new("Part")
	p.Transparency = transp
	p.CanCollide = false
	p.Locked = true
	if not type(anchored) == "boolean" then
	p.Anchored = true	
	end
	p.Anchored = anchored
	p.Color = color
	p.Size = size
	p.Position = rootpart.Position
	p.Material = mat
	p.Parent = parent
	if shape then
	if shape == "ball" then
	local m = Instance.new("SpecialMesh",p)
	m.MeshType = "Sphere"	
	end	
	end
	return p
end

function weldBetween(a, b)
	    local weldd = Instance.new("ManualWeld")
	    weldd.Part0 = a
	    weldd.Part1 = b
	    weldd.C0 = CFrame.new()
	    weldd.C1 = b.CFrame:inverse() * a.CFrame
	    weldd.Parent = a
	    return weldd
end

function weld(parent, part0, part1, c0, c1)
	local w = Instance.new("Weld")
	w.Part0 = part0
	w.Part1 = part1
	w.C0 = c0
	w.C1 = c1
	w.Parent = parent
	return w
end

function sound(id, parent, vol, pitch)
		local so = Instance.new("Sound")
		so.EmitterSize = 5*vol
		so.Parent = parent
		so.Volume = vol
		so.Pitch = pitch
		so.SoundId = "rbxassetid://"..id
		so:Play()
	return so
end

function Tween(obj,prop,easing,easingdir,timer)
local easin = Enum.EasingStyle[easing]
local easindir = Enum.EasingDirection[easingdir]
local tweeninf = TweenInfo.new(
	timer/1,	
	easin,
	easindir,
	0,
	false,
	0
)
local props = prop
local tweenanim = tweenservice:Create(obj,tweeninf,props)
tweenanim:Play()
end

function raycast(pos, dir, range, ignore)
	return workspace:FindPartOnRay(Ray.new(pos, dir.unit * range), ignore)
end

function castray(start, endp, dist, ignore)
	local dir = cf(start,endp).lookVector
	return raycast(start, dir, dist, ignore)
end

function Effect(tblee)
	coroutine.resume(coroutine.create(function()
		local origpos = (tblee.cf or nil)
		local moveto = (tblee.moveto or nil)
		local color = (tblee.clr or Color3.new(0,0,0))
		local color2 = (tblee.clr2 or nil)
		local defaultsize = (tblee.size or vt(2,2,2))
		local material = (tblee.mat or "Neon")
		local locker = (tblee.lock or false)
		local rotateX = (tblee.radX or 0)
		local rotateY = (tblee.radY or 0)
		local rotateZ = (tblee.radZ or 0)
		local secondsize = (tblee.size2 or vt(4,4,4))
		local acttime = (tblee.waits or 100)
		local transpar = (tblee.tran or 0)
		local transpar2 = (tblee.tran2 or 1)
		local typeofmesh = (tblee.mtype or "S")
		local movingspeed = nil
		local mesh = nil
		if typeof(origpos) == "Vector3"then origpos=cf(origpos) end 
		if typeof(moveto) == "CFrame"then moveto=moveto.p end 
		if typeof(color) == "BrickColor"then color=color.Color end 
		if typeof(color2) == "BrickColor"then color2=color2.Color end
		if origpos then
		local p=Instance.new("Part",effects)p.Anchored=true p.CanCollide=false p.Color=color p.CFrame=origpos p.Material=material p.Size=Vector3.new(1,1,1)p.CanCollide=false p.Transparency=transpar p.CastShadow=false p.Locked=true
		if typeofmesh == "Box" or typeofmesh == "B" or typeofmesh == "1" then
			mesh=Instance.new("BlockMesh",p)mesh.Scale=defaultsize
		elseif typeofmesh == "Sphere" or typeofmesh == "S" or typeofmesh == "2" then
			mesh=Instance.new("SpecialMesh",p)mesh.MeshType="Sphere"mesh.Scale=defaultsize
		elseif typeofmesh == "Cylinder" or typeofmesh == "C" or typeofmesh == "3" then
			mesh=Instance.new("SpecialMesh",p)mesh.MeshType="Cylinder"mesh.Scale=defaultsize
		elseif typeofmesh == "Slash" or typeofmesh == "SL" or typeofmesh == "4" then
			mesh=Instance.new("SpecialMesh",p)mesh.MeshType="FileMesh"mesh.MeshId="rbxassetid://662585058"mesh.Scale = vt(defaultsize.X/10,0,defaultsize.X/10)
		elseif typeofmesh == "Wave" or typeofmesh == "W" or typeofmesh == "5" then
			mesh=Instance.new("SpecialMesh",p)mesh.MeshType="FileMesh"mesh.MeshId="rbxassetid://20329976"mesh.Scale = vt(0,0,-defaultsize.X/8)
		end
		if locker == true then
			p.Position = origpos.p
			if typeofmesh == "Cylinder" or typeofmesh == "C" or typeofmesh == "3" then 
				p.CFrame = cf(p.Position,moveto)*cf(0,0,-(p.Size.Z/1.5))*angles(0,rad(90),0)
			else
				p.CFrame = cf(p.Position,moveto)*cf(0,0,-(p.Size.Z/1.5))
			end
		else
			if typeofmesh == "Cylinder" or typeofmesh == "C" or typeofmesh == "3" then 
				p.CFrame = origpos*CFrame.Angles(0,math.rad(90),0)
			else
				p.CFrame = origpos
			end
		end
		if color2 then
		Tween(p,{Color = color2},"Linear","In",acttime/60)
		end	
		if mesh then
			if  moveto then
				movingspeed=(origpos.p - moveto).Magnitude/acttime
			end
			local endsize=(defaultsize - secondsize)
			local endtranpar=transpar-transpar2
			for i = 1, acttime+1 do Swait()
				mesh.Scale=mesh.Scale-endsize/acttime
				p.Transparency = p.Transparency - endtranpar/acttime
				p.CFrame=p.CFrame*CFrame.Angles(math.rad(rotateX),math.rad(rotateY),math.rad(rotateZ))
				if moveto ~= nil then
					local a = p.Orientation
					if typeofmesh == "Cylinder" or typeofmesh == "C" or typeofmesh == "3" then 
						p.CFrame = CFrame.new(p.Position,moveto)*CFrame.new(0,0,-movingspeed)*CFrame.Angles(0,math.rad(90),0)
					else
						p.CFrame = CFrame.new(p.Position,moveto)*CFrame.new(0,0,-movingspeed)
					end
					p.Orientation = a
				end
			end
			p:Destroy()
		end
		elseif origpos == nil then
		warn("Origpos is nil!")
		end
	end))
end

function attcf(p)
	return p.Parent.CFrame*cf(p.Position)
end

function unanchor(what)
	if typeof(what) == "Instance" then
	for _,v in pairs(what:GetDescendants()) do
		if v:IsA("BasePart") then
			v.Anchored = false
		end
	end
	else
	warn("not an instance")
	end
end

function randomangle()
	return angles(rad(random(1,360)),rad(random(1,360)),rad(random(1,360)))
end

function randompos(num,typ)
	if typ == "vt" or not typ then
		return vt(random(-num,num),random(-num,num),random(-num,num))
	elseif typ == "cf" then
		return cf(random(-num,num),random(-num,num),random(-num,num))
	end
end

function deathfunction(model)
	model:BreakJoints()
	for _, c in pairs(model:GetChildren()) do
		if c:IsA("BasePart") and c.Name ~= "HumanoidRootPart" then
			if c.Name == "Head" then
				
				elseif c.Name ~= "HumanoidRootPart" then
					
			end
		end
	end
	debris:AddItem(model,6)
end

function applydamage(humanoid,damage)
end

function aoe(pos,range,min,max,fling,instakill,knock)
end

function agyro()
	local g = Instance.new("BodyGyro",rootpart)
	g.D = 25
	g.P = 20000
	g.MaxTorque = vt(0,4000000,0)
	g.CFrame = cf(rootpart.Position,mouse.Hit.p)
	coroutine.wrap(function()
		repeat
			Swait()
			g.CFrame = cf(rootpart.Position,mouse.Hit.p)
		until not attack
		g:Destroy()
	end)()
end



songid = 0
speed = 16
riflequipped = true

for _,v in next, humanoid:GetPlayingAnimationTracks() do
	 v:Stop();
end
character.Animate.Parent = nil

local la = Instance.new("Weld")
local ra = Instance.new("Weld")

ra.Name = "ra"
ra.Part0 = torso 
ra.C0 = cf(1.5, 0.5, 0)
ra.C1 = cf(0, 0.5, 0)
ra.Part1 = rightarm
ra.Parent = torso  

la.Name = "la"
la.Part0 = torso 
la.C0 = cf(-1.5, 0.5, 0)
la.C1 = cf(0, 0.5, 0) 
la.Part1 = leftarm
la.Parent = torso

local lh = weld(leftleg,torso,leftleg,cf(-.5,-1,0),d)
lh.C1 = cf(0,1,0)
local rh = weld(rightleg,torso,rightleg,cf(.5,-1,0),d)
rh.C1 = cf(0,1,0)

rifle = script.rifle

local hat2 = gp(cplayer, "Keyboard", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = rifle.Handle
att2.Position = Vector3.new(0, 0.35, -0.25) 
att2.Rotation = Vector3.new(0, -90, 0)

shirt = script.s
shirt.Parent = character
pants = script.p
pants.Parent = character
head.Transparency = 1
eqpweld = weld(rifle,rifle.eqp,rightarm,d,d)
uneqpweld = weld(rifle,rifle.uneqp,torso,d,d)
uneqpweld.Parent = nil
unanchor(rifle)
rifle.Parent = character
riflejoint = rifle.joint2.Weld
shg = script.shotgun

local hat2 = gp(cplayer, "AJBackAccessory", "Accessory")
local handle2 = gp(hat2, "Handle", "BasePart")
local att2 = gp(handle2, "att1_Handle", "Attachment")
att2.Parent = shg.shotgun
att2.Position = Vector3.new(0, 0, 0) 
att2.Rotation = Vector3.new(0, -90, -15)

seqw = weld(shg,shg.eqp,rightarm,d,d)
seqw.Parent = nil
suneq = weld(shg,shg.uneqp,torso,d,d)
unanchor(shg)
shg.Parent = character
weap = "rifle"
shotgunjoint = shg.joint2.Weld
changin = false
gren = script.gren
gren.Parent = nil
		
for _,v in pairs(rifle:GetChildren()) do
			if v:IsA("BasePart") then
				v.Transparency = 1
			end
		end
		
for _,v in pairs(shg:GetChildren()) do
			if v:IsA("BasePart") then
				v.Transparency = 1
			end
		end

function switch()
	if not attack and weap == "rifle" then
		changin = true
		delay(.5,function()
		eqpweld.Parent = nil
		uneqpweld.Parent = rifle
		seqw.Parent = shg
		suneq.Parent = nil
		weap = "shotgun"
		changin = false
		end)
	elseif not attack and weap == "shotgun" then
		delay(.5,function()
		eqpweld.Parent = rifle
		uneqpweld.Parent = nil
		seqw.Parent = nil
		suneq.Parent = shg
		weap = "rifle"
		changin = false
		end)
	end
end




function cs()
	if songid == 0 then
		songid = 1
	elseif song == 1 then
		songid = 2
	end
end

function shoot()
	attack = true
	  	local Time,Easing,Direction = .35,'Quad','Out'
  Tween(rootjoint,{C0 = cf(-0.1,-0.4,0)*angles(rad(0),rad(20.4),rad(0))*rootc0},Easing,Direction,Time)
  Tween(lh,{C0 = cf(-0.5,-0.7,-0.4)*angles(rad(-18.9),rad(6.8),rad(-10.1))},Easing,Direction,Time)
  Tween(rh,{C0 = cf(0.6,-0.6,-0.7)*angles(rad(-7.2),rad(-9.8),rad(3.4))},Easing,Direction,Time)
  Tween(la,{C0 = cf(-0.9,0.1,-0.8)*angles(rad(117.8),rad(5.9),rad(40.5))},Easing,Direction,Time)
  Tween(ra,{C0 = cf(1.4,0.5,-0.7)*angles(rad(93.6),rad(8.2),rad(-23))},Easing,Direction,Time)
  Tween(neck,{C0 = neckc0*cf(0,0,0)*angles(rad(0),rad(0),rad(-20.4))},Easing,Direction,Time)
  Tween(riflejoint,{C0 = cf(-0.3,0,0.1)*angles(rad(-7.6),rad(-46.2),rad(-10.4))},Easing,Direction,Time)
  swait(Time)
	repeat
		rootpart.Anchored = true
		swait(.02)
		sound(1044434118,rifle.Hole,3,random(8,12)/10)
		  	local Time,Easing,Direction = .075,'Linear','Out'
  Tween(rootjoint,{C0 = cf(-0.1,-0.4,0+.15)*angles(rad(0),rad(20.4),rad(0))*rootc0},Easing,Direction,Time)
  Tween(lh,{C0 = cf(-0.5,-0.7,-0.4-.15)*angles(rad(-18.9),rad(6.8),rad(-10.1))},Easing,Direction,Time)
  Tween(rh,{C0 = cf(0.6,-0.6,-0.7-.15)*angles(rad(-7.2),rad(-9.8),rad(3.4))},Easing,Direction,Time)
  Tween(la,{C0 = cf(-0.9,0.1,-0.8+.3)*angles(rad(117.8),rad(5.9),rad(40.5))},Easing,Direction,Time)
  Tween(ra,{C0 = cf(1.4,0.5,-0.7+.3)*angles(rad(93.6),rad(8.2),rad(-23))},Easing,Direction,Time)
  Tween(neck,{C0 = neckc0*cf(0,0,0)*angles(rad(0),rad(0),rad(-20.4))},Easing,Direction,Time)
  Tween(riflejoint,{C0 = cf(-0.3,0,0.1)*angles(rad(-7.6),rad(-46.2),rad(-10.4))},Easing,Direction,Time)
  swait(Time)
local h,p = castray(rifle.Hole.Position,mouse.Hit.p, 500,character)
local di = (p - rifle.Hole.Position).Magnitude
Effect({cf=cf(rifle.Hole.Position,p)*cf(0,0,-di/2),moveto=nil,clr=Color3.new(1,1,0),clr2=Color3.new(.9,.9,0),mtype="Box",waits=10,size=Vector3.new(.05,.05,di),size2=Vector3.new(.1,.1,di),radX=0,radY=0,radZ=0,mat="Neon",lock=false,tran=0,tran2=1})
Effect({cf=rifle.Hole.Position,moveto=nil,clr=Color3.new(1,1,0),clr2=Color3.new(.9,.9,0),mtype="Box",waits=15,size=Vector3.new(.1,.1,.1),size2=Vector3.new(.3,.3,.3),radX=random(-8,8),radY=random(-8,8),radZ=random(-8,8),mat="Neon",lock=false,tran=0,tran2=1})
if h then
	if h.Parent:FindFirstChildOfClass("Humanoid") then
		applydamage(h.Parent:FindFirstChildOfClass("Humanoid"),random(30,35))
		local bl = part(h.Parent,"Granite",0,BrickColor.new("Crimson").Color,vt(.2,.2,.2),false,"ball")
		bl.Position = p
		weldBetween(bl,h)
		Tween(bl,{Transparency = 1},"Linear","In",1)
		debris:AddItem(bl,1.01)
		sound(1565725028,bl,6,random(9,12)/10)
	end
end
	  	local Time,Easing,Direction = .075,'Linear','Out'
  Tween(rootjoint,{C0 = cf(-0.1,-0.4,0)*angles(rad(0),rad(20.4),rad(0))*rootc0},Easing,Direction,Time)
  Tween(lh,{C0 = cf(-0.5,-0.7,-0.4)*angles(rad(-18.9),rad(6.8),rad(-10.1))},Easing,Direction,Time)
  Tween(rh,{C0 = cf(0.6,-0.6,-0.7)*angles(rad(-7.2),rad(-9.8),rad(3.4))},Easing,Direction,Time)
  Tween(la,{C0 = cf(-0.9,0.1,-0.8)*angles(rad(117.8),rad(5.9),rad(40.5))},Easing,Direction,Time)
  Tween(ra,{C0 = cf(1.4,0.5,-0.7)*angles(rad(93.6),rad(8.2),rad(-23))},Easing,Direction,Time)
  Tween(neck,{C0 = neckc0*cf(0,0,0)*angles(rad(0),rad(0),rad(-20.4))},Easing,Direction,Time)
  Tween(riflejoint,{C0 = cf(-0.3,0,0.1)*angles(rad(-7.6),rad(-46.2),rad(-10.4))},Easing,Direction,Time)
  swait(Time)
	until mousehold == false
	rootpart.Anchored = false
	attack = false
end

function shoot2()
	attack = true
	  	local Time,Easing,Direction = .35,'Quad','Out'
  Tween(rootjoint,{C0 = cf(-0.1,-0.4,0)*angles(rad(0),rad(20.4),rad(0))*rootc0},Easing,Direction,Time)
  Tween(lh,{C0 = cf(-0.5,-0.7,-0.4)*angles(rad(-18.9),rad(6.8),rad(-10.1))},Easing,Direction,Time)
  Tween(rh,{C0 = cf(0.6,-0.6,-0.7)*angles(rad(-7.2),rad(-9.8),rad(3.4))},Easing,Direction,Time)
  Tween(la,{C0 = cf(-0.9,0.1,-0.8)*angles(rad(117.8),rad(5.9),rad(40.5))},Easing,Direction,Time)
  Tween(ra,{C0 = cf(1.4,0.5,-0.7)*angles(rad(93.6),rad(8.2),rad(-23))},Easing,Direction,Time)
  Tween(neck,{C0 = neckc0*cf(0,0,0)*angles(rad(0),rad(0),rad(-20.4))},Easing,Direction,Time)
  Tween(shotgunjoint,{C0 = cf(-0.3,0,0.1)*angles(rad(-7.6),rad(-46.2),rad(-10.4))},Easing,Direction,Time)
  swait(Time)
		rootpart.Anchored = true
		sound(2001619675,shg.Hole,3,random(8,12)/10)
		  	local Time,Easing,Direction = .2,'Back','Out'
  Tween(rootjoint,{C0 = cf(-0.1,-0.4,0)*angles(rad(5.9),rad(20.4),rad(0))*rootc0},Easing,Direction,Time)
  Tween(lh,{C0 = cf(-0.6,-0.7,-0.3)*angles(rad(-24.2),rad(7.5),rad(-12.1))},Easing,Direction,Time)
  Tween(rh,{C0 = cf(0.6,-0.7,-0.6)*angles(rad(-13.1),rad(-9.5),rad(1.3))},Easing,Direction,Time)
  Tween(la,{C0 = cf(-1.1,0.1,-0.3)*angles(rad(125.8),rad(8.4),rad(39))},Easing,Direction,Time)
  Tween(ra,{C0 = cf(1.2,0.6,-0.1)*angles(rad(101.5),rad(11.1),rad(-23.4))},Easing,Direction,Time)
  Tween(neck,{C0 = neckc0*cf(0,0,0)*angles(rad(7.7),rad(0),rad(-20.3))},Easing,Direction,Time)
  Tween(shotgunjoint,{C0 = cf(-0.3,0,0.1)*angles(rad(-7.6),rad(-46.2),rad(-10.4))},Easing,Direction,Time)
for i = 1,6 do
local h,p = castray(shg.Hole.Position,mouse.Hit*randompos(1,"cf").p, 500,character)
local di = (p - shg.Hole.Position).Magnitude
local ab
if not h then ab = randompos(12) else ab = vt(0,0,0) end
Effect({cf=cf(shg.Hole.Position,p+ab)*cf(0,0,-di/2),moveto=nil,clr=Color3.new(1,1,0),clr2=Color3.new(.9,.9,0),mtype="Box",waits=10,size=Vector3.new(.05,.05,di),size2=Vector3.new(.1,.1,di),radX=0,radY=0,radZ=0,mat="Neon",lock=false,tran=0,tran2=1})
Effect({cf=shg.Hole.Position,moveto=nil,clr=Color3.new(1,1,0),clr2=Color3.new(.9,.9,0),mtype="Box",waits=15,size=Vector3.new(.1,.1,.1),size2=Vector3.new(.3,.3,.3),radX=random(-8,8),radY=random(-8,8),radZ=random(-8,8),mat="Neon",lock=false,tran=0,tran2=1})
if h then
	if h.Parent:FindFirstChildOfClass("Humanoid") then
		applydamage(h.Parent:FindFirstChildOfClass("Humanoid"),random(20,25))
		local bl = part(h.Parent,"Granite",0,BrickColor.new("Crimson").Color,vt(.2,.2,.2),false,"ball")
		bl.Position = p
		weldBetween(bl,h)
		Tween(bl,{Transparency = 1},"Linear","In",1)
		debris:AddItem(bl,1.01)
		sound(1565725028,bl,6,random(9,12)/10)
	end
end
end
  swait(Time)
	  	local Time,Easing,Direction = .15,'Linear','Out'
  Tween(rootjoint,{C0 = cf(-0.1,-0.4,0)*angles(rad(0),rad(20.4),rad(0))*rootc0},Easing,Direction,Time)
  Tween(lh,{C0 = cf(-0.5,-0.7,-0.4)*angles(rad(-18.9),rad(6.8),rad(-10.1))},Easing,Direction,Time)
  Tween(rh,{C0 = cf(0.6,-0.6,-0.7)*angles(rad(-7.2),rad(-9.8),rad(3.4))},Easing,Direction,Time)
  Tween(la,{C0 = cf(-0.9,0.1,-0.8)*angles(rad(117.8),rad(5.9),rad(40.5))},Easing,Direction,Time)
  Tween(ra,{C0 = cf(1.4,0.5,-0.7)*angles(rad(93.6),rad(8.2),rad(-23))},Easing,Direction,Time)
  Tween(neck,{C0 = neckc0*cf(0,0,0)*angles(rad(0),rad(0),rad(-20.4))},Easing,Direction,Time)
  Tween(shotgunjoint,{C0 = cf(-0.3,0,0.1)*angles(rad(-7.6),rad(-46.2),rad(-10.4))},Easing,Direction,Time)
  swait(Time)
  	local Time,Easing,Direction = .2,'Quad','InOut'
  Tween(rootjoint,{C0 = cf(-0.1,-0.4,-0.1)*angles(rad(6.6),rad(32.4),rad(-1.5))*rootc0},Easing,Direction,Time)
  Tween(lh,{C0 = cf(-0.6,-0.7,-0.3)*angles(rad(-24.2),rad(7.5),rad(-12.1))},Easing,Direction,Time)
  Tween(rh,{C0 = cf(0.6,-0.7,-0.6)*angles(rad(-13.1),rad(-9.5),rad(1.3))},Easing,Direction,Time)
  Tween(la,{C0 = cf(-1.6,0.7,-0.3)*angles(rad(127),rad(-1),rad(-22.6))},Easing,Direction,Time)
  Tween(ra,{C0 = cf(0.9,0.5,-0.9)*angles(rad(105.8),rad(0.4),rad(-53.5))},Easing,Direction,Time)
  Tween(neck,{C0 = neckc0*cf(0.1,0,0)*angles(rad(0.1),rad(0),rad(5.7))},Easing,Direction,Time)
  Tween(shotgunjoint,{C0 = cf(0.3,-0.1,0)*angles(rad(23),rad(42),rad(-18.1))},Easing,Direction,Time)
  swait(Time)
sound(3299747822,shg.Hole,4,1)
  	local Time,Easing,Direction = .2,'Back','Out'
  Tween(rootjoint,{C0 = cf(-0.1,-0.4,0)*angles(rad(6.2),rad(26.8),rad(-0.7))*rootc0},Easing,Direction,Time)
  Tween(lh,{C0 = cf(-0.6,-0.7,-0.3)*angles(rad(-24.2),rad(7.5),rad(-12.1))},Easing,Direction,Time)
  Tween(rh,{C0 = cf(0.6,-0.7,-0.6)*angles(rad(-13.1),rad(-9.5),rad(1.3))},Easing,Direction,Time)
  Tween(la,{C0 = cf(-1.6,0.3,-0.5)*angles(rad(127),rad(-1),rad(19.5))},Easing,Direction,Time)
  Tween(ra,{C0 = cf(0.9,0.5,-0.9)*angles(rad(105.8),rad(0.4),rad(-53.5))},Easing,Direction,Time)
  Tween(neck,{C0 = neckc0*cf(0.1,0,0)*angles(rad(0.4),rad(0),rad(11.4))},Easing,Direction,Time)
  Tween(shotgunjoint,{C0 = cf(0.3,-0.1,0)*angles(rad(23),rad(42),rad(-18.1))},Easing,Direction,Time)
  swait(Time)
	rootpart.Anchored = false
	attack = false
end

function grenade()
	attack = true
	  	local Time,Easing,Direction = .45,'Quad','InOut'
  Tween(rootjoint,{C0 = cf(0,0,0)*angles(rad(0),rad(52.9),rad(0))*rootc0},Easing,Direction,Time)
  Tween(lh,{C0 = cf(-0.5,-1,-0.1)*angles(rad(1.4),rad(5.6),rad(-2.4))},Easing,Direction,Time)
  Tween(rh,{C0 = cf(0.5,-1,-0.2)*angles(rad(-0.9),rad(-9.7),rad(3))},Easing,Direction,Time)
  Tween(la,{C0 = cf(-1.4,0.5,0)*angles(rad(14.2),rad(14.4),rad(1.2))},Easing,Direction,Time)
  Tween(ra,{C0 = cf(1.6,0.5,0)*angles(rad(117.8),rad(25.4),rad(26.7))},Easing,Direction,Time)
  Tween(neck,{C0 = neckc0*cf(0,0,0)*angles(rad(0),rad(0),rad(-52.9))},Easing,Direction,Time)
  swait(Time)
  	local Time,Easing,Direction = .3,'Quad','InOut'
  Tween(rootjoint,{C0 = cf(0,0,0)*angles(rad(0),rad(43),rad(0))*rootc0},Easing,Direction,Time)
  Tween(lh,{C0 = cf(-0.5,-1,-0.1)*angles(rad(1.4),rad(5.6),rad(-2.4))},Easing,Direction,Time)
  Tween(rh,{C0 = cf(0.5,-1,-0.2)*angles(rad(-0.9),rad(-9.7),rad(3))},Easing,Direction,Time)
  Tween(la,{C0 = cf(-1.4,0.7,0.1)*angles(rad(-162.6),rad(-15),rad(-10.9))},Easing,Direction,Time)
  Tween(ra,{C0 = cf(1.2,0.8,0.5)*angles(rad(-103.3),rad(0.5),rad(-36.2))},Easing,Direction,Time)
  Tween(neck,{C0 = neckc0*cf(0,0,0)*angles(rad(0),rad(0),rad(-43))},Easing,Direction,Time)
local gren2 = gren:Clone()
gren2.Anchored = false
gren2.Parent = effects
gren2.CFrame = leftarm.CFrame
local grenw = weld(gren2,gren2,leftarm,d*angles(rad(90),0,0)*cf(0,1,0),d)
  swait(Time)
  	local Time,Easing,Direction = .3,'Quint','Out'
  Tween(rootjoint,{C0 = cf(0,0,0)*angles(rad(-9.2),rad(-18.5),rad(0))*rootc0},Easing,Direction,Time)
  Tween(lh,{C0 = cf(-0.6,-0.9,-0.4)*angles(rad(11.4),rad(15.8),rad(-5.5))},Easing,Direction,Time)
  Tween(rh,{C0 = cf(0.4,-1,-0.2)*angles(rad(7.4),rad(-9.8),rad(0))},Easing,Direction,Time)
  Tween(la,{C0 = cf(-0.4,0.5,-1.2)*angles(rad(37.1),rad(8.9),rad(61.6))},Easing,Direction,Time)
  Tween(ra,{C0 = cf(1.2,0.8,0.5)*angles(rad(-103.3),rad(0.5),rad(-36.2))},Easing,Direction,Time)
  Tween(neck,{C0 = neckc0*cf(-0,0,-0)*angles(rad(-7.9),rad(0),rad(18.4))},Easing,Direction,Time)
local proj = gren:Clone()
sound(4847394559,leftarm,4,1)
proj.Anchored = false
proj.Parent = effects
proj.Position = gren2.Position
proj.CFrame = cf(proj.Position,mouse.Hit.p)*cf(0,0,-4)
gren2:Destroy()
proj.Velocity = proj.CFrame.lookVector*125
proj.CanCollide = true
delay(1,function()
aoe(proj.Position,20,0,0,200,true)
local s = sound(2814354338,proj,2,1)
s.PlayOnRemove = true
Effect({cf=proj.Position,moveto=nil,clr=Color3.fromRGB(255,150,0),clr2=Color3.fromRGB(255,100,0),mtype="S",waits=60/1.5,size=Vector3.new(1,1,1),size2=Vector3.new(40,40,40),radX=0,radY=0,radZ=0,mat="Neon",lock=false,tran=0,tran2=1})
Effect({cf=proj.Position,moveto=nil,clr=Color3.fromRGB(255,100,0),clr2=Color3.fromRGB(255,150,0),mtype="S",waits=60/1.5,size=Vector3.new(1,1,1),size2=Vector3.new(30,30,30),radX=0,radY=0,radZ=0,mat="Neon",lock=false,tran=0,tran2=1})
for i = 1,3 do
Effect({cf=proj.CFrame*randomangle(),moveto=nil,clr=Color3.new(1,1,1),clr2=Color3.new(1,1,1),mtype="Wave",waits=75/1.5,size=Vector3.new(1,.1,3),size2=Vector3.new(45,.2,45),radX=0,radY=random(-4,4),radZ=0,mat="Neon",lock=false,tran=0,tran2=1})
end
proj:Destroy()	
end)
  swait(Time)

attack = false
end

run = false

function trip()
	attack = true
	Swait()
	local Time,Easing,Direction = .3,'Quart','Out'
  Tween(rootjoint,{C0 = cf(0,-0.3,0.1)*angles(rad(-12.9),rad(73.3),rad(0))*rootc0},Easing,Direction,Time)
  Tween(lh,{C0 = cf(-0.5,-0.8,-0.1)*angles(rad(3.8),rad(6.1),rad(3.9))},Easing,Direction,Time)
  Tween(rh,{C0 = cf(0.5,-0.8,-0.4)*angles(rad(-12),rad(8.2),rad(57.6))},Easing,Direction,Time)
  Tween(la,{C0 = cf(-1.5,0.5,0.1)*angles(rad(7.5),rad(17.6),rad(-21.2))},Easing,Direction,Time)
  Tween(ra,{C0 = cf(0.9,0.5,-0.9)*angles(rad(93.5),rad(7.9),rad(-58.5))},Easing,Direction,Time)
  Tween(neck,{C0 = neckc0*cf(0,0,0)*angles(rad(0),rad(0),rad(-73.3))},Easing,Direction,Time)
	rootpart.Velocity = rootpart.CFrame.lookVector*235
	aoe(rightleg.Position,3,10,17,0,false,true)
  swait(Time)
aoe(rightleg.Position,7,10,17,0,false,true)
	attack = false
end

mouse.Button1Down:Connect(function()
	mousehold = true
	if attack == false and weap == "rifle" and not changin then
		shoot()
	elseif not attack and weap == "shotgun" and not changin then
		shoot2()
	end
end)

mouse.Button1Up:Connect(function()
	mousehold = false
end)

mouse.KeyDown:Connect(function(k)
	keyhold = true
	if k == "z" and attack == false then
		grenade()
	end
	
	if k == "x" and attack == false then
		trip()
	end
	if k == "c" and attack == false then
		
	end
	
	if k == "v" and attack == false then
		
	end
	
	if k == "b" and attack == false then
		
	end
	
	if k == "g" and run == false then run = true elseif k == "2" and run == true then run = false end
	
	if k == "q" and not attack and not changin then
		switch()
	end
	
	if k == "m" and attack == false then cs() end
end)

mouse.KeyUp:Connect(function(k)
	keyhold = false
end)

while true do
	Swait()
	sine = sine + change
	local torsoverticalvel = rootpart.Velocity.Y
	local torsovel = (rootpart.Velocity * vt(1, 0, 1)).Magnitude
	local hitfloor,hitpos,normal = raycast(rootpart.Position,(cf(rootpart.Position, rootpart.Position+vt(0,-1,0))).lookVector,4+humanoid.HipHeight,character)
	local speedval = 10/(humanoid.WalkSpeed/16)
	local Walking = humanoid.MoveDirection.magnitude>0
	local FwdDir = (Walking and humanoid.MoveDirection*rootpart.CFrame.lookVector or vt())
	local RigDir = (Walking and humanoid.MoveDirection*rootpart.CFrame.rightVector or vt())
	local Vec = {
		X=RigDir.X+RigDir.Z,
		Z=FwdDir.X+FwdDir.Z
	};
	local Divide = 1
	if(Vec.Z<0)then
		Divide=math.clamp(-(1.25*Vec.Z),1,2)
	end
	Vec.Z = Vec.Z/Divide
	Vec.X = Vec.X/Divide
	if torsoverticalvel > 1 and not hitfloor then
		anim = "jump"
		if attack == false then
		local Alpha = .2
  		rootjoint.C0 = rootjoint.C0:lerp(cf(0,0,0)*angles(rad(15.2),rad(0),rad(0))*rootc0,Alpha)
  		lh.C0 = lh.C0:lerp(cf(-0.5,-1.1,0)*angles(rad(-21),rad(0),rad(0)),Alpha)
 		rh.C0 = rh.C0:lerp(cf(0.5,-0.4,-1)*angles(rad(-18.6),rad(0),rad(0)),Alpha)
  		la.C0 = la.C0:lerp(cf(-1.5,0.5,0.2)*angles(rad(-9.7),rad(8.3),rad(-8.1)),Alpha)
  		ra.C0 = ra.C0:lerp(cf(1.5,0.5,0.2)*angles(rad(-9.7),rad(-8.3),rad(8.1)),Alpha)
  		neck.C0 = neck.C0:lerp(neckc0*cf(0,0,0)*angles(rad(-9.6),rad(0),rad(0)),Alpha)
		end
	elseif torsoverticalvel < -1 and not hitfloor then
		anim = "fall"
		local Alpha = .2
		if attack == false then
 		rootjoint.C0 = rootjoint.C0:lerp(cf(0,0,-0)*angles(rad(-16.1),rad(0),rad(0))*rootc0,Alpha)
  		lh.C0 = lh.C0:lerp(cf(-0.5,-1,-0.3)*angles(rad(-12.5),rad(0),rad(0)),Alpha)
  		rh.C0 = rh.C0:lerp(cf(0.5,-0.2,-1.1)*angles(rad(-16),rad(0),rad(0)),Alpha)
		la.C0 = la.C0:lerp(cf(-1.6,0.1+.085*sin(sine/35),-0.4)*angles(rad(72.3),rad(1.5),rad(-18.9)),Alpha)
  		ra.C0 = ra.C0:lerp(cf(1.3,0.4+.085*sin(sine/35),-0.9)*angles(rad(71.8),rad(14.3),rad(-66.2)),Alpha)
  		neck.C0 = neck.C0:lerp(neckc0*cf(0,0,0)*angles(rad(-5),rad(0),rad(0)),Alpha)
		end
	elseif torsovel < 1 and hitfloor then
		anim = "idle"
		local Alpha = .1
		if attack == false then
 		rootjoint.C0 = rootjoint.C0:lerp(cf(0,0+.07*cos(sine/27),0)*angles(rad(0),rad(45.5+1*cos(sine/(27*2))),rad(0))*rootc0,Alpha)
  		lh.C0 = lh.C0:lerp(cf(-0.5,-1-.07*cos(sine/27),-0.1)*angles(rad(1.4),rad(5.6-1*cos(sine/(27*2))),rad(-2.4)),Alpha)
 		rh.C0 = rh.C0:lerp(cf(0.5,-1-.07*cos(sine/27),-0.2)*angles(rad(-0.9),rad(-9.7-1*cos(sine/(27*2))),rad(3)),Alpha)
  		la.C0 = la.C0:lerp(cf(-1.3,0.1+.085*sin(sine/27),-0.4)*angles(rad(75.1),rad(28.8),rad(-25.2)),Alpha)
  		ra.C0 = ra.C0:lerp(cf(1.1,0.3+.085*sin(sine/27),-0.8)*angles(rad(95.2),rad(17.7),rad(-57.2)),Alpha)
 		neck.C0 = neck.C0:lerp(neckc0*cf(0,0,0)*angles(rad(2.75*sin(sine/27)),rad(-3*cos(sine/(27*2))),rad(-45.5)),Alpha)
		end
	elseif torsovel > 1 and torsovel < 22 and hitfloor then
		anim = "walk"
		local Alpha = .1
		rootjoint.C0 = rootjoint.C0:lerp(cf(0,.14-.07*cos(sine/speedval*2),0)*angles(rad(-15*Vec.Z),rad(5*cos(sine/speedval)),rad(-12.5*Vec.X))*rootc0,Alpha)
  		lh.C0 = lh.C0:lerp(cf(-0.5,-1+.18*sin(sine/speedval),-.1+.12*sin(sine/speedval)*Vec.Z)*angles(rad(-40*cos(sine/speedval)*Vec.Z),rad(2*cos(sine/speedval)),rad(-20*cos(sine/speedval)*Vec.X)),Alpha)
  		rh.C0 = rh.C0:lerp(cf(0.5,-1-.18*sin(sine/speedval),-.1-.12*sin(sine/speedval)*Vec.Z)*angles(rad(40*cos(sine/speedval)*Vec.Z),rad(-2*cos(sine/speedval)),rad(20*cos(sine/speedval)*Vec.X)),Alpha)
   		neck.C0 = neck.C0:lerp(neckc0*cf(0,0,0)*angles(rad(-2),rad(0),rad(-5*cos(sine/speedval)-26*Vec.X)),Alpha)
		la.C0 = la.C0:lerp(cf(-1.3,0.1,-0.4)*angles(rad(75.1),rad(28.8),rad(-25.2)),Alpha)
  		ra.C0 = ra.C0:lerp(cf(1.1,0.3,-0.8)*angles(rad(95.2),rad(17.7),rad(-57.2)),Alpha)
	elseif torsovel >= 22 and hitfloor then
		anim = "run"
		runval = 6
		local Alpha = .1
		rootjoint.C0 = rootjoint.C0:lerp(cf(0,.2-.15*cos(sine/runval*2),0)*angles(rad(-15*Vec.Z),rad(5*sin(sine/runval)),rad(-12.5*Vec.X))*rootc0,Alpha)
  		lh.C0 = lh.C0:lerp(cf(-0.5,-1+.45*sin(sine/runval),-.1+.2*sin(sine/runval)*Vec.Z)*angles(rad(-60*cos(sine/runval)*Vec.Z),rad(4*cos(sine/runval)),rad(-40*cos(sine/runval)*Vec.X)),Alpha)
  		rh.C0 = rh.C0:lerp(cf(0.5,-1-.45*sin(sine/runval),-.1-.2*sin(sine/runval)*Vec.Z)*angles(rad(60*cos(sine/runval)*Vec.Z),rad(-4*cos(sine/runval)),rad(40*cos(sine/runval)*Vec.X)),Alpha)
  		la.C0 = la.C0:lerp(cf(-1.3,0.1,-0.4)*angles(rad(75.1),rad(28.8),rad(-25.2)),Alpha)
  		ra.C0 = ra.C0:lerp(cf(1.1,0.3,-0.8)*angles(rad(95.2),rad(17.7),rad(-57.2)),Alpha)
  		neck.C0 = neck.C0:lerp(neckc0*cf(0,0,0)*angles(rad(0),rad(0),rad(-5*sin(sine/runval)-26*Vec.X)),Alpha)
	end
	if attack == false and weap == "rifle" then
		riflejoint.C0 = riflejoint.C0:lerp(cf(0,0,0)*angles(rad(0.3),rad(25.4),rad(-3.7)),.1)
		shotgunjoint.C0 = shotgunjoint.C0:lerp(d,.1)
	elseif not attack and weap == "shotgun" then
		riflejoint.C0 = riflejoint.C0:lerp(d,.1)
		shotgunjoint.C0 = shotgunjoint.C0:lerp(cf(0,0,0)*angles(rad(0.3),rad(25.4),rad(-3.7)),.1)
	end
	if run == false then
		speed = 16
	elseif run == true then
		speed = 35
	end
	song.SoundId,song.Looped,song.Pitch,song.Volume,song.Playing = "rbxassetid://"..songid,true,1,3,true
	humanoid.Health,humanoid.MaxHealth,humanoid.WalkSpeed = 9e9,9e9,speed
end
